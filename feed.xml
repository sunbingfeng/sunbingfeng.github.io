<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://sunbingfeng.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sunbingfeng.github.io/" rel="alternate" type="text/html" /><updated>2025-09-17T12:37:32+00:00</updated><id>https://sunbingfeng.github.io/feed.xml</id><title type="html">Bill’s Tech Blog</title><subtitle>To Be Excellent</subtitle><entry><title type="html">什么是KLT变换？</title><link href="https://sunbingfeng.github.io/blog/KLT_SVD/" rel="alternate" type="text/html" title="什么是KLT变换？" /><published>2025-09-13T00:00:00+00:00</published><updated>2025-09-13T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/KLT_SVD</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/KLT_SVD/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第10篇，介绍统计数学中的KLT变换与线性代数中SVD分解的关系。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>以前看论文，经常看到KLT变换，但是不知道具体是做什么用途，也没有深入去了解。最近在反复琢磨SVD分解的时候，看到了一段文字，深受启发，因此想展开去分析分析。</p>

<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q3/klt_svd_connection.png" align="center" class="center_img" />
<figcaption>Figure 1: 摘录至Gilbert老爷子的“LINEAR ALGEGRA AND LEARNING FROM DATA”</figcaption>
</figure>

<p>原来这个SVD跟统计学中的KLT变换还能联系起来，很有意思，那么我们一起去看一下吧。</p>

<h2 id="karhunen-loeve-transform-klt"><strong>Karhunen-Loeve Transform (KLT)</strong></h2>

<p>KLT变换，全称为Karhunen-Loève Transform，由Kari Karhunen and Michel Loève两位数学家名字命名而来。那其到底是做啥的？我们问一下AI。</p>

<blockquote>
  <p>Me: Explain the Karhunen-Loeve Transform, and its connection with SVD.</p>
</blockquote>

<blockquote>
  <p>AI: Excellent question! The Karhunen-Loeve (KL) transform is a fundamental concept in signal processing and data analysis. Let me explain it and its deep connection with SVD.</p>
</blockquote>

<h3 id="definition"><strong>Definition</strong></h3>
<p>The Karhunen-Loeve transform is a <strong>linear transformation</strong> that finds the <strong>optimal basis</strong> for representing a random process with minimum mean square error.</p>

<h3 id="mathematical-formulation"><strong>Mathematical Formulation</strong></h3>

<h4 id="for-a-random-vector-x"><strong>For a Random Vector X:</strong></h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Y = A * X
</code></pre></div></div>

<p>Where <code class="language-plaintext highlighter-rouge">A</code> is the KL transform matrix that:</p>
<ol>
  <li><strong>Decorrelates</strong> the components of X</li>
  <li><strong>Maximizes variance</strong> in the first component</li>
  <li><strong>Minimizes reconstruction error</strong></li>
</ol>

<h3 id="key-properties"><strong>Key Properties</strong></h3>

<ol>
  <li><strong>Optimality</strong>: Minimizes mean square reconstruction error</li>
  <li><strong>Decorrelation</strong>: Transformed components are uncorrelated</li>
  <li><strong>Variance ordering</strong>: Components ordered by decreasing variance</li>
  <li><strong>Orthogonality</strong>: Transform matrix is orthogonal</li>
</ol>

<h2 id="connection-with-svd"><strong>Connection with SVD</strong></h2>

<h3 id="the-fundamental-relationship"><strong>The Fundamental Relationship</strong></h3>

<p>The KL transform is <strong>mathematically equivalent</strong> to SVD when applied to data matrices!</p>

<h4 id="for-data-matrix-x"><strong>For Data Matrix X:</strong></h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SVD(X) = U * Σ * V^T
</code></pre></div></div>

<p>The KL transform is:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = V^T  (transpose of right singular vectors)
</code></pre></div></div>

<h3 id="why-this-works"><strong>Why This Works</strong></h3>

<h4 id="1-covariance-matrix-connection"><strong>1. Covariance Matrix Connection:</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Data matrix X (centered)</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="err">₁ᵀ</span><span class="p">]</span>
    <span class="p">[</span><span class="n">x</span><span class="err">₂ᵀ</span><span class="p">]</span>
    <span class="p">[</span><span class="n">x</span><span class="err">₃ᵀ</span><span class="p">]</span>
    <span class="p">...</span>

<span class="c1">// Covariance matrix</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="o">^</span><span class="n">T</span> <span class="o">*</span> <span class="n">X</span>

<span class="c1">// SVD of X</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">U</span> <span class="o">*</span> <span class="err">Σ</span> <span class="o">*</span> <span class="n">V</span><span class="o">^</span><span class="n">T</span>

<span class="c1">// Covariance matrix in terms of SVD</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span> <span class="o">*</span> <span class="err">Σ²</span> <span class="o">*</span> <span class="n">V</span><span class="o">^</span><span class="n">T</span>
</code></pre></div></div>

<h4 id="2-eigenvalue-decomposition"><strong>2. Eigenvalue Decomposition:</strong></h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C is symmetric, so:</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">V</span> <span class="o">*</span> <span class="err">Λ</span> <span class="o">*</span> <span class="n">V</span><span class="o">^</span><span class="n">T</span>

<span class="c1">// Where Λ = (1/n) * Σ²</span>
<span class="c1">// V contains the eigenvectors (KL basis)</span>
</code></pre></div></div>

<h2 id="step-by-step-kl-transform"><strong>Step-by-Step KL Transform</strong></h2>

<h3 id="1-center-the-data"><strong>1. Center the Data:</strong></h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Remove mean</span>
<span class="n">centered_X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="2-compute-covariance-matrix"><strong>2. Compute Covariance Matrix:</strong></h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">centered_X</span><span class="o">^</span><span class="n">T</span> <span class="o">*</span> <span class="n">centered_X</span>
</code></pre></div></div>

<h3 id="3-eigenvalue-decomposition"><strong>3. Eigenvalue Decomposition:</strong></h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C</span> <span class="o">=</span> <span class="n">V</span> <span class="o">*</span> <span class="err">Λ</span> <span class="o">*</span> <span class="n">V</span><span class="o">^</span><span class="n">T</span>
</code></pre></div></div>

<h3 id="4-kl-transform"><strong>4. KL Transform:</strong></h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span> <span class="o">=</span> <span class="n">V</span><span class="o">^</span><span class="n">T</span> <span class="o">*</span> <span class="n">centered_X</span>
</code></pre></div></div>
<h2 id="applications-of-kl-transform"><strong>Applications of KL Transform</strong></h2>

<h3 id="1-principal-component-analysis-pca"><strong>1. Principal Component Analysis (PCA):</strong></h3>
<ul>
  <li><strong>Data compression</strong>: Reduce dimensionality</li>
  <li><strong>Noise reduction</strong>: Remove low-variance components</li>
  <li><strong>Feature extraction</strong>: Find important patterns</li>
</ul>

<h3 id="2-signal-processing"><strong>2. Signal Processing:</strong></h3>
<ul>
  <li><strong>Image compression</strong>: JPEG, MPEG</li>
  <li><strong>Speech recognition</strong>: Feature extraction</li>
  <li><strong>Radar</strong>: Target detection</li>
</ul>

<h2 id="advantages-of-kl-transform"><strong>Advantages of KL Transform</strong></h2>

<h3 id="1-optimality"><strong>1. Optimality:</strong></h3>
<ul>
  <li><strong>Minimum error</strong>: Best linear representation</li>
  <li><strong>Maximum variance</strong>: First component captures most information</li>
  <li><strong>Decorrelated</strong>: Components are independent</li>
</ul>

<h3 id="2-efficiency"><strong>2. Efficiency:</strong></h3>
<ul>
  <li><strong>Compression</strong>: Reduce data dimensionality</li>
  <li><strong>Noise reduction</strong>: Filter out low-variance components</li>
  <li><strong>Computational</strong>: Efficient SVD implementation</li>
</ul>

<h2 id="example">Example</h2>
<p>上面讲了那么多，我们用一个例子来说明。</p>

<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q3/linear_regression.png" align="center" class="center_img" />
<figcaption>Figure 2: 线性回归问题</figcaption>
</figure>

<p>这个例子比较简单，就是给出一组2D平面上的采样点：\(s_i\)，求出一个最佳的拟合直线。这个问题有很多种解法，我们尝试用SVD方法来解一下。</p>

<p>首先，计算采样点中心，然后将所有的采样点去中心化。(<em>这里补充说明一下，去中心化是因为方向向量的求解跟这个中心无关。而且，去中心化是计算协方差的必备操作。对应到KLT变换，前文AI也讲了其主要针对零均值随机变量。</em>)</p>

\[\begin{align}
s_c = \frac{1}{n}\sum s_i \\
x_i = s_i - s_c
\end{align}\]

<p>接下来，可以从两个方向来分析：</p>

<ul>
  <li>求解最优的直线方向向量\(v\)，以让\(x_i\)与该向量最大程度共线:</li>
</ul>

\[\begin{equation}
    \argmax_{v} \sum v^T {x_i}{x_i}^T v
    \end{equation}\]

<ul>
  <li>求解最优的直线法向向量\(n\), 以让\(x_i\)到该法向的投影距离最小：</li>
</ul>

\[\begin{equation}
    \argmin_{n} \sum n^T {x_i}{x_i}^T n
    \end{equation}\]

<p>我们可以发现，不论是求方向向量还是法向向量，其都需要对\(x_i\)做协方差统计：</p>

\[C =  \sum {x_i}{x_i}^T\]

<p>那么，问题就演变成了求解\(x^TCx\)最大化或者最小化的问题。这是一个什么问题，二次型求解问题，因为协方差矩阵C肯定是对称矩阵。</p>

<p>回顾SVD的知识，我们可以知道，SVD分解最大/小奇异值分别对应二次型的最大最小值。那么就只需要对协方差矩阵做SVD分解，找到奇异值对应的方向向量即为我们所要的结果。</p>

<p>我们知道对称方阵的SVD分解：\(C=VDV^T\)，其找到一组正交基对协方差矩阵做正交分解，正交基就在\(V\)中。那么，如果用其做KLT变换，\(y=V^Tx\)，将可以得到采样随机变量x在正交基上的向量表达。这也就是上文AI所说的，随机变量去相关操作。</p>

<p>有了这一组正交基，我们就可以对随机变量做正交基分解，或者用前k个分量对该随机变量做最小误差拟合，以保证信息损失最小化。这就是KLT变换的内容了。这样，KLT和SVD就关联起来了。</p>

<h2 id="conclusion">Conclusion</h2>

<p>到此为止，通过理论与实际结合，我们揭示了KLT变换与SVD分解之间的深层数学联系，下面简单总结一下：</p>

<ol>
  <li>
    <p><strong>KLT变换的本质</strong>：KLT（Karhunen-Loève Transform）是一种寻找最优基的线性变换，能够以最小均方误差表示随机过程，实现数据的去相关和方差最大化。</p>
  </li>
  <li>
    <p><strong>与SVD的数学等价性</strong>：当应用于数据矩阵时，KLT变换在数学上等价于SVD分解。具体而言，KLT变换矩阵就是SVD分解中右奇异向量矩阵的转置（A = V^T）。</p>
  </li>
  <li>
    <p><strong>几何直观理解</strong>：通过线性回归的例子，我们看到了KLT变换的几何意义——它找到数据的主要变化方向，将原始数据投影到这些正交基上，实现数据的解耦和降维。</p>
  </li>
  <li>
    <p><strong>实际应用价值</strong>：KLT变换在PCA、信号处理、图像压缩等领域有广泛应用，其最优性使其成为数据分析和特征提取的重要工具。</p>
  </li>
</ol>

<p>从协方差矩阵的角度看，KLT变换实际上是在寻找协方差矩阵的特征向量。通过SVD分解，我们不仅得到了数据的奇异值分解，同时也获得了协方差矩阵的特征值分解，这种双重性质使得SVD成为连接线性代数和统计学的桥梁。理解KLT与SVD的关系有助于我们：</p>

<ul>
  <li>更好地理解PCA等降维方法的数学原理</li>
  <li>在信号处理中选择合适的变换方法</li>
  <li>在实际应用中灵活运用这些数学工具</li>
</ul>

<p>这种跨领域的数学联系体现了数学的统一性和美感，也为我们解决实际问题提供了更强大的工具。</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="math" /><summary type="html"><![CDATA[详解KLT跟SVD的关系]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Setup Android Dev Environment</title><link href="https://sunbingfeng.github.io/blog/Setup_Android_dev/" rel="alternate" type="text/html" title="Setup Android Dev Environment" /><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/Setup_Android_dev</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/Setup_Android_dev/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第9篇，介绍从一个小白的视角搭建Android开发环境。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>最近工作需要在Android平台上实现一个测试APP，但是以前没有过Android开发的经验，连开发环境都不知道怎么搭建。还好，我们有AI的帮助，废话不说，开干吧。</p>

<h2 id="setup-dev-environment">Setup Dev Environment</h2>

<p>一般来说，Android应用开发都是在Android Studio或者Jetbrains 等IDE中进行的。这些IDE有一个共同的特点，那就是太庞大，不够轻便。现在VSCode生态这么好，我们很自然的想到是不是有基于VSCode的开发流程。</p>

<p>接着我们去Google一下，找到一篇还算完整的<a href="https://dev.to/allenchrios/optimizing-android-development-key-features-of-vs-code-to-enhance-your-workflow-54i5">Tutorial</a>，教我们如何一步步搭建Android开发环境。整理一下，主要有几个关键的点：</p>

<ol>
  <li>安装JDK，可以去<a href="https://www.oracle.com/java/technologies/downloads/">Java官网</a>下载</li>
  <li>安装Android SDK，这里只需要下载command line tools就行。去到<a href="https://developer.android.com/studio?hl=zh-cn#downloads">Android开发者网站</a>，滑到最下面，下载对应的cli tools。然后解压到一个目录下(建议<code class="language-plaintext highlighter-rouge">Android/sdk</code>)。</li>
  <li>安装VSCode相关插件: Android For VSCode, 配置launch.json</li>
  <li>
    <p>配置环境变量这里总结下几个必须要配置的：</p>

    <table>
      <thead>
        <tr>
          <th>Env</th>
          <th>Description</th>
          <th>Example</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>JAVA_HOME</strong></td>
          <td>步骤1安装的JDK的路径</td>
          <td><strong>D:\Program Files\Eclipse Adoptium\jdk-21.0.8.9-hotspot</strong></td>
        </tr>
        <tr>
          <td><strong>ANDROID_HOME</strong></td>
          <td>步骤2解压的SDK路径</td>
          <td><strong>D:\Android\sdk</strong></td>
        </tr>
        <tr>
          <td><strong>PATH</strong></td>
          <td>将platform_tools目录加到PATH</td>
          <td><strong>%ANDROID_HOME%\platform-tools\</strong></td>
        </tr>
        <tr>
          <td><strong>ANDROID_AVD_HOME</strong></td>
          <td>安卓模拟器路径</td>
          <td><strong>%ANDROID_HOME%.android\avd</strong></td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h2 id="demo-project">Demo Project</h2>
<p>目前，大都利用Gradle去管理Anroid开发环境。起初，连Gradle是啥我都不知道，但是Google一下后大概直到其是干啥的了。那么，一个使用Gradle管理的工程长什么样呢，这里给一个示例：</p>

<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q3/gradle_proj.png" alt="Demo project" align="center" class="center_img" />
<figcaption>Figure 1: 示例工程结构</figcaption>
</figure>

<p>其中，有几个点说明一下：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.vscode</code>是VSCode配置文件夹</li>
  <li><code class="language-plaintext highlighter-rouge">gradle/wrapper</code>是gradle创建wrapper环境所用的配置文件夹</li>
  <li><code class="language-plaintext highlighter-rouge">settings.gradle</code>和<code class="language-plaintext highlighter-rouge">build.gradle</code>是用来描述工程编译设置项，比如：所依赖的SDK/Java/Kotlin版本，三方库版本等</li>
  <li><code class="language-plaintext highlighter-rouge">gradlew.bat</code>或者<code class="language-plaintext highlighter-rouge">gradlew</code>，其是工程所使用的gradle脚本，后续所有的编译安装操作都是用这个脚本。<code class="language-plaintext highlighter-rouge">.bat</code>脚本是给Windows环境用的。</li>
</ul>

<p>在我调试用的这个开源工程上，没有gradlew脚本。起初，我Google了一下怎么利用系统Gradle来生成这个脚本，一直都没有成功。最后，我直接让AI给我生成了一个gradlew.bat脚本。简单看了一眼其内容，大致为读取JAVA环境配置，并且基于<code class="language-plaintext highlighter-rouge">gradle/wrapper</code>下面的设置生成gradle环境。该环境是局部有效的，放置于本工程的<code class="language-plaintext highlighter-rouge">.gradle</code>目录下面。</p>

<p>插一句嘴，这个利用gradlew脚本来管理工程的一个好处，即是可以保证所有人的开发环境都是一致的，都是基于wrapper配置来统一生成的。这样方便做版本控制，以及协同开发。</p>

<p>有了这个脚本后，我们就可以执行工程编译，所使用的命令是：<code class="language-plaintext highlighter-rouge">.\gradlew.bat assembleDebug</code>。编译过程中，会去拉取一些依赖库。在国内，可以配置一些大厂的镜像源，以加速拉去进度。配置方法很多，可以参考<a href="https://blog.iprac.cn/blogs/628.html">Gradle国内源配置</a>。</p>

<p>编译成功后，我们需要找一个模拟器来试运行一下程序。下面，我们直接问AI，如何搭建一个emulator。</p>

<p>其给出的步骤如下：</p>
<ul>
  <li>创建一个模拟器，<code class="language-plaintext highlighter-rouge">avdmanager.bat create avd -n "TestDevice" -k "system-images;android-26;google_apis;x86" -d "pixel"</code></li>
  <li>可以检查下emulator有没有生成成功：<code class="language-plaintext highlighter-rouge">emulator.exe -list-avds</code></li>
  <li>启动模拟器：<code class="language-plaintext highlighter-rouge">emulator.exe -avd TestDevice</code></li>
</ul>

<p>模拟器安装好以后，就可以将编译成功的app安装到模拟器上调试运行了。</p>
<ul>
  <li>安装app：<code class="language-plaintext highlighter-rouge">gradlew.bat installDebug</code></li>
  <li>启动app: <code class="language-plaintext highlighter-rouge">adb.exe shell am start -n [app name]</code></li>
</ul>

<p>最后，上一个模拟器启动后的图片。</p>

<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q3/emulator.png" alt="Demo project" align="center" class="center_img" />
<figcaption>Figure 2：模拟器界面</figcaption>
</figure>

<h2 id="conclusion">Conclusion</h2>

<p>这次完全是一个小白入手搭建Android开发环境并且跑通程序调试运行的经历。虽然技术含量不高，但是作为一个从0到1的过程，还是有必要记录一下。过程中，也有遇到一些问题，AI通过读取命令的报错信息，直接就给解决了，本文没有完全摘录。因此，本文并不是一个一站式解决方案，只是列了一个梗概，各中细节还是需要各位借助AI自己去摸索。</p>

<p>日常工作中，如果有需要开发一些简单测试APP，你完全不用惧怕。如果能在开源社区找到一个相近的工程，那么借助AI改巴改巴实现你的需求，是完全没问题的。甚至你也可以完全借助AI去给你从0到1搭建工程，去一步步实现。</p>

<p>总之，只要你敢想，没有什么可以阻挡！</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="review" /><summary type="html"><![CDATA[Android Setup]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">SFINAE到底是不是Error？</title><link href="https://sunbingfeng.github.io/blog/SFINAE/" rel="alternate" type="text/html" title="SFINAE到底是不是Error？" /><published>2025-08-22T00:00:00+00:00</published><updated>2025-08-22T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/SFINAE</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/SFINAE/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第8篇，介绍C++中的SFINAE机制。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>在C++中，如果你有接触Template metaprogramming(TMP)，那么SFINAE就是一个绕不去的存在。其全称为”Substitution Failure Is Not An Error”，指的是模板替换中发生的Failure就不是一个Error。Failure都不是Error，那岂不是可以为所欲为了？它究竟想解决一个什么问题？SFINAE到底是不是Error？接下来我们一探究竟。</p>

<h2 id="sfinae-is-indeed-error">SFINAE is indeed ERROR</h2>

<p>我们写一个简单的例子：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">div</span><span class="p">(</span><span class="kt">char</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="n">I</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// this overload is selected when I is odd</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"div() called - I is odd"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">div</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">div</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>div模板函数接收一个编译时常量整数I，如果I为奇数，那么<code class="language-plaintext highlighter-rouge">char(*)[true]</code> 等价于 <code class="language-plaintext highlighter-rouge">char(*)[1]</code>， 其定义一个指向大小为1的char数组的指针，其是一个有效的类型，函数重载成功，<code class="language-plaintext highlighter-rouge">div&lt;1&gt;()</code>可以正确编译使用。</p>

<p>但是如果I为偶数, <code class="language-plaintext highlighter-rouge">char(*)[false]</code> 等价于 <code class="language-plaintext highlighter-rouge">char(*)[0]</code>，其表征一个指向大小为0的数组的指针，在C++中这是非法操作，因此<code class="language-plaintext highlighter-rouge">div&lt;2&gt;()</code>编译不会通过。</p>

<p>那么问题来了，不是说”Substitution Failure Is Not An Error”吗，为啥编译不通过呢？</p>

<p>这里援引一下cppreference中关于SFINAE的一段描述:</p>

<blockquote>

  <p>This rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error.</p>

</blockquote>

<p>通俗的解释，如果substituion failure发生在重载解析的时候，其就不是Error，其他情况下该报错还是得报错。</p>

<p>对上面的程序，添加一个重载实现，如下所示，那么程序就可以正常编译了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">div</span><span class="p">(</span><span class="kt">char</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="n">I</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// this overload is selected when I is even</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"div() called - I is even"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="a-step-further">A Step Further</h2>

<p>下面例子实现了一个简易的Matrix类。鉴于Vector也是一个Matrix，因此其很自然的想基于TMP思想实现一个只适用于Vector的函数vectorOnlyFunc。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="c1">// Test class template with different SFINAE scenarios</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Cols</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">Scalar</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">enum</span><span class="p">{</span><span class="n">_Rows</span> <span class="o">=</span> <span class="n">Rows</span><span class="p">,</span> <span class="n">_Cols</span> <span class="o">=</span> <span class="n">Cols</span><span class="p">};</span>

    <span class="c1">// Constructor</span>
    <span class="n">Matrix</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Matrix&lt;"</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">Rows</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">Cols</span> <span class="o">&lt;&lt;</span> <span class="s">"&gt; constructed"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">Rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">Cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="nf">vectorOnlyFunc</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vectorOnlyFunc() called - only for vectors"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">_OtherCols</span><span class="p">,</span>
             <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">Rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">_OtherCols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="nf">vectorMultiply</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Cols</span><span class="p">,</span> <span class="n">_OtherCols</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vectorMultiply() called with "</span> <span class="o">&lt;&lt;</span> <span class="n">_OtherCols</span> <span class="o">&lt;&lt;</span> <span class="s">" columns"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Test 1: 2x2 matrix (non-vector)</span>
    <span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">matrix2x2</span><span class="p">;</span>
    <span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">vector1x3</span><span class="p">;</span>

    <span class="c1">// This will work - SFINAE with function template parameter</span>
    <span class="n">vector1x3</span><span class="p">.</span><span class="n">vectorOnlyFunc</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>直接上结果，这个例子是编译不通过的。你可能会疑惑，我实例化了一个2x2的matrix和一个1x3的vector，我也没有针对matrix调用vectorOnlyFunc，为什么会编译不通过？</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-std</span><span class="o">=</span>c++17 <span class="nt">-Wall</span> <span class="nt">-Wextra</span> <span class="nt">-O2</span> <span class="nt">-o</span> sfinae_test sfinae_test.cpp
sfinae_test.cpp: In instantiation of ‘class Matrix&lt;float, 2, 2&gt;’:
sfinae_test.cpp:31:25:   required from here
sfinae_test.cpp:16:10: error: no <span class="nb">type </span>named ‘type’ <span class="k">in</span> ‘struct std::enable_if&lt;<span class="nb">false</span>, bool&gt;’
   16 |     void vectorOnlyFunc<span class="o">()</span> <span class="o">{</span>
      |          ^~~~~~~~~~~~~~
</code></pre></div></div>

<p>其实，上面这个例子是大家刚接触模板编程时很容易犯的一个错误。这里我们来问一下AI，下面是AI的答复：</p>

<blockquote>
  <p>You’re absolutely right! This confirms the issue. Even though you never call the test function, it still fails to compile. This is a classic SFINAE problem.</p>
</blockquote>

<blockquote>
  <p>The issue is that <strong>the function template is being instantiated during class template instantiation</strong>, not when it’s called. When you create a <code class="language-plaintext highlighter-rouge">Matrix&lt;Scalar, 2, 2&gt;</code> object, the compiler tries to instantiate ALL member functions of the class template, including your test function.</p>
</blockquote>

<blockquote>
  <p>For a 2×2 matrix, the condition <code class="language-plaintext highlighter-rouge">_Rows == 1 || _Cols == 1</code> evaluates to <code class="language-plaintext highlighter-rouge">false</code>, so <code class="language-plaintext highlighter-rouge">std::enable_if&lt;false, bool&gt;::type</code> has no <code class="language-plaintext highlighter-rouge">type</code> member, causing the compilation error.</p>
</blockquote>

<blockquote>
  <p>The problem with your current approach is that <strong>SFINAE only works at function call time, not at class template instantiation time</strong>. When the class template is instantiated, all member functions must be valid, even if they’re never called.</p>
</blockquote>

<blockquote>
  <p>For your use case, <code class="language-plaintext highlighter-rouge">static_assert</code> is probably the cleanest solution since you want to prevent the function from being used on non-vector matrices.</p>
</blockquote>

<p>简单概述一下，虽然matrix2x没有调用vectOnlyFunc，但是其在实例化的时候，由于<code class="language-plaintext highlighter-rouge">std::enable_if_t&lt;Rows == 1 || Cols == 1, bool&gt;</code>都是确定的类型，没有待替换的模板类型，因此其被立即解析。由于<code class="language-plaintext highlighter-rouge">Rows == 1 || Cols == 1</code>为false，<code class="language-plaintext highlighter-rouge">std::enable_if_t&lt;false, bool&gt;</code>是一个未定义的类型，从而导致编译错误。这种情况下，SFINAE机制不是免死金牌，也是不受用的。</p>

<p>那么，正确的实现应该是什么样子的呢，AI给出了下面的几种机制：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. **Use `std::enable_if_t` with a dummy parameter:**</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Dummy</span> <span class="o">=</span> <span class="kt">void</span><span class="p">,</span> 
         <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">_Rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">_Cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">&gt;</span><span class="o">*</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">vectorOnlyFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vectorOnlyFunc"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 2. **Use `static_assert` (Recommended for this case):**</span>
<span class="kt">void</span> <span class="nf">vectorOnlyFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">_Rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">_Cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"This function is only valid for vectors"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vectorOnlyFunc"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>简单介绍下上面提到的2种方案：</p>

<ul>
  <li>方案1，使用一个dummy的模板类型。加入Dummy类型后，vectorOnlyFunc不会在类的实例化的时候就触发编译，只有遇到调用的地方才会。</li>
  <li>方案2，使用<code class="language-plaintext highlighter-rouge">static_assert</code>，在不满足Vector条件的时候就触发编译报警。</li>
</ul>

<p>其实，这两种方案本质是差不多的，都是在遇到调用的时候，检测到条件不满足就触发编译报警。从代码可读性的角度来看，第二种方案反而更好一些。这一点，在cppreference也有提到：</p>

<blockquote>
  <p>Where applicable, tag dispatch, if constexpr(since C++17), and concepts (since C++20) are usually preferred over use of SFINAE.
static_assert is usually preferred over SFINAE if only a conditional compile time error is wanted.(since C++11)</p>
</blockquote>

<h2 id="right-way-to-utilize-sfinae">Right way to utilize SFINAE?</h2>

<p>那么，最终的问题来了，SFINAE机制究竟怎么用才是正道？那自然是函数重载了。</p>

<p>下面是实现一个Matrix的点乘操作的例子。一般情况下，矩阵乘的结果还是一个矩阵。但是如果是向量点乘，那么其结果应该是一个数才更合理。
这个时候利用SFINAE机制来实现函数的重载就相当方便了：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Cols</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">enum</span><span class="p">{</span><span class="n">_Rows</span> <span class="o">=</span> <span class="n">Rows</span><span class="p">,</span> <span class="n">_Cols</span> <span class="o">=</span> <span class="n">Cols</span><span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">_Other_Cols</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">_Rows</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">_Other_Cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span><span class="o">::</span><span class="n">type</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">_Cols</span><span class="p">,</span> <span class="n">_Other_Cols</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">MultResultType</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">_Rows</span><span class="p">,</span> <span class="n">_Other_Cols</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="n">MultResultType</span> <span class="n">M</span><span class="p">;</span>

        <span class="c1">// [TODO] do matrix multipy, and return a matrix</span>

        <span class="k">return</span> <span class="n">M</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Specialized for vector dot product.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">_Other_Cols</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">_Rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">_Other_Cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span><span class="o">::</span><span class="n">type</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
    <span class="n">Scalar</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">_Cols</span><span class="p">,</span> <span class="n">_Other_Cols</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Scalar</span> <span class="n">result</span><span class="p">;</span>

        <span class="c1">// [TODO] do vector multipy, and return a scalar.</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的例子中，判断条件比较简单，利用模板特化也可以做。但是对于其他的应用，如果判断条件很复杂，用模板特化就没有SFINAE机制来的方便。</p>

<h2 id="conclusion">Conclusion</h2>
<p>SFINAE（Substitution Failure Is Not An Error）是一个强大但经常被误解的C++模板机制，它既是模板元编程的福音，也是陷阱。其不是免死金牌，需要深入理解后才可以高效的使用。</p>

<p>实际开发中，要注意SFINAE的一些关键限制：</p>

<ul>
  <li>类模板实例化：SFINAE无法在类模板实例化过程中保护成员函数。当类模板被实例化时，所有成员函数都必须是有效的，即使它们从未被调用。</li>
  <li>立即类型解析：在类实例化时确定的模板参数（如Rows和Cols）会立即被解析，而不是延迟到函数调用时。</li>
  <li>语法错误 vs. 类型失败：SFINAE优雅地处理类型替换失败，但无法克服无效的C++语法或语言规则违反。</li>
</ul>

<p>从C++17开始，C++提供了更优雅的解决方案，比如: <code class="language-plaintext highlighter-rouge">if constexpr</code>, <code class="language-plaintext highlighter-rouge">concept</code>。条件允许的情况下，推荐使用最新的一些模板meta-programming技巧。</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="c++" /><summary type="html"><![CDATA[C++ 模板元编程]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Deep Dive into Butterworth Low Pass Filter</title><link href="https://sunbingfeng.github.io/blog/Butterworth_LPF/" rel="alternate" type="text/html" title="Deep Dive into Butterworth Low Pass Filter" /><published>2025-08-15T00:00:00+00:00</published><updated>2025-08-15T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/Butterworth_LPF</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/Butterworth_LPF/"><![CDATA[<blockquote>
  <p>This is the 7th article in the AI Chat series, where we’ll explore the principles and implementation of the Butterworth low-pass filter.</p>
</blockquote>

<h2 id="table-of-contents">Table of Contents</h2>
<ol>
  <li><a href="#1-introduction">Introduction</a></li>
  <li><a href="#2-mathematical-foundation">Mathematical Foundation</a></li>
  <li><a href="#3-filter-design-process">Filter Design Process</a></li>
  <li><a href="#4-implementation-methods">Implementation Methods</a></li>
  <li><a href="#5-experimental-validation">Experimental Validation</a></li>
  <li><a href="#6-conclusion">Conclusion</a></li>
</ol>

<h2 id="1-introduction">1. Introduction</h2>

<p>In signal processing, particularly for positioning and sensor data applications, filter selection is crucial. The Butterworth low-pass filter has become one of the most widely used filters due to its:</p>
<ul>
  <li><strong>Maximally flat frequency response</strong> in the passband</li>
  <li><strong>Simple mathematical structure</strong></li>
  <li><strong>Straightforward implementation</strong></li>
  <li><strong>Predictable behavior</strong></li>
</ul>

<p>This article will guide you through the complete design process, from mathematical principles to practical implementation, using a real-world example from the VQF IMU attitude fusion algorithm.</p>

<h2 id="2-mathematical-foundation">2. Mathematical Foundation</h2>

<h3 id="21-butterworth-filter-characteristics">2.1 Butterworth Filter Characteristics</h3>

<p>The Butterworth filter is designed to have a <strong>maximally flat magnitude response</strong> in the passband. For a second-order filter, this means:</p>
<ul>
  <li><strong>DC gain</strong>: 1 (0 dB)</li>
  <li><strong>Cutoff frequency</strong>: -3 dB point</li>
  <li><strong>Roll-off rate</strong>: -40 dB/decade after cutoff</li>
</ul>

<h3 id="22-normalized-prototype-filter">2.2 Normalized Prototype Filter</h3>

<p>The standard approach starts with a <strong>normalized prototype</strong> filter with cutoff frequency at 1 rad/s:</p>

<p><strong>Transfer Function:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H(s) = 1 / (s² + √2s + 1)
</code></pre></div></div>

<p><strong>Why 1 rad/s?</strong></p>
<ul>
  <li>This is a <strong>convention</strong> in filter design</li>
  <li>Provides a <strong>standardized starting point</strong></li>
  <li>Makes calculations and comparisons easier</li>
  <li>All Butterworth filters begin with this normalized form</li>
</ul>

<p><strong>Mathematical Verification:</strong>
At ω = 1 rad/s:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H(j·1) = 1 / ((j·1)² + √2·j·1 + 1)
        = 1 / (-1 + j√2 + 1)
        = 1 / (j√2)
</code></pre></div></div>

<p>The magnitude is exactly <code class="language-plaintext highlighter-rouge">1/√2 ≈ 0.707</code>, which corresponds to the -3 dB cutoff point.</p>

<h2 id="3-filter-design-process">3. Filter Design Process</h2>

<h3 id="31-traditional-design-steps">3.1 Traditional Design Steps</h3>

<p>The classical approach involves four main steps:</p>

<ol>
  <li><strong>Normalized Prototype</strong>: Start with H(s) = 1/(s² + √2s + 1)</li>
  <li><strong>Frequency Scaling</strong>: Scale to desired cutoff frequency ωc</li>
  <li><strong>Bilinear Transform</strong>: Convert from s-domain to z-domain</li>
  <li><strong>Coefficient Extraction</strong>: Derive the difference equation coefficients</li>
</ol>

<h3 id="32-frequency-scaling">3.2 Frequency Scaling</h3>

<p>To scale the cutoff frequency from 1 rad/s to ωc:</p>

<p><strong>Substitute s → s/ωc:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H(s) = 1 / ((s/ωc)² + √2(s/ωc) + 1)
     = ωc² / (s² + √2ωc·s + ωc²)
</code></pre></div></div>

<h3 id="33-bilinear-transform">3.3 Bilinear Transform</h3>

<p>Convert from continuous-time to discrete-time:</p>

<p><strong>Transform Formula:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s = (2/T) × (z-1)/(z+1)
</code></pre></div></div>

<p>Where T is the sampling period.</p>

<h2 id="4-implementation-methods">4. Implementation Methods</h2>

<h3 id="41-vqf-implementation-approach">4.1 VQF Implementation Approach</h3>

<p>The VQF algorithm uses a more sophisticated approach that <strong>implicitly handles frequency pre-warping</strong>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">filterCoeffs</span><span class="p">(</span><span class="n">vqf_real_t</span> <span class="n">tau</span><span class="p">,</span> <span class="n">vqf_real_t</span> <span class="n">Ts</span><span class="p">,</span> <span class="kt">double</span> <span class="n">outB</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">outA</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Ts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="c1">// Calculate pre-warped cutoff frequency</span>
    <span class="kt">double</span> <span class="n">fc</span> <span class="o">=</span> <span class="p">(</span><span class="n">M_SQRT2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">M_PI</span><span class="p">))</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">tau</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">C</span> <span class="o">=</span> <span class="n">tan</span><span class="p">(</span><span class="n">M_PI</span><span class="o">*</span><span class="n">fc</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">Ts</span><span class="p">));</span>
    <span class="kt">double</span> <span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="n">C</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">C</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="c1">// Filter coefficients</span>
    <span class="kt">double</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="o">/</span><span class="n">D</span><span class="p">;</span>
    <span class="n">outB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b0</span><span class="p">;</span>      <span class="c1">// b0</span>
    <span class="n">outB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b0</span><span class="p">;</span>    <span class="c1">// b1</span>
    <span class="n">outB</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b0</span><span class="p">;</span>      <span class="c1">// b2</span>
    
    <span class="n">outA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">D</span><span class="p">;</span>           <span class="c1">// a1</span>
    <span class="n">outA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">+</span><span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="p">)</span><span class="o">/</span><span class="n">D</span><span class="p">;</span>   <span class="c1">// a2</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="42-why-vqf-method-works">4.2 Why VQF Method Works</h3>

<p>The key insight is <strong>frequency pre-warping compensation</strong>:</p>

<p><strong>Pre-warping Formula:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ωc = (2/T) × tan(ωd×T/2)
</code></pre></div></div>

<p>Where:</p>
<ul>
  <li><strong>ωc</strong> = pre-warped cutoff frequency</li>
  <li><strong>ωd</strong> = desired digital cutoff frequency</li>
  <li><strong>T</strong> = sampling period</li>
</ul>

<p><strong>Why This Matters:</strong></p>
<ul>
  <li>The bilinear transform introduces <strong>frequency distortion</strong></li>
  <li>Low frequencies are compressed, high frequencies are expanded</li>
  <li>Without pre-warping, the digital filter would have the wrong cutoff frequency</li>
  <li>The VQF method automatically compensates for this distortion</li>
</ul>

<h3 id="43-traditional-vs-vqf-approach">4.3 Traditional vs. VQF Approach</h3>

<table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Traditional Method</th>
      <th>VQF Method</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Frequency Handling</strong></td>
      <td>Direct ωc usage</td>
      <td>Pre-warped ωc</td>
    </tr>
    <tr>
      <td><strong>Denominator</strong></td>
      <td>4 + 2√2ωc + ωc²</td>
      <td>C² + √2C + 1</td>
    </tr>
    <tr>
      <td><strong>Pre-warping</strong></td>
      <td>Manual calculation</td>
      <td>Built-in</td>
    </tr>
    <tr>
      <td><strong>Accuracy</strong></td>
      <td>Requires manual compensation</td>
      <td>Automatic</td>
    </tr>
  </tbody>
</table>

<h2 id="5-experimental-validation">5. Experimental Validation</h2>

<h3 id="51-test-setup">5.1 Test Setup</h3>

<p>Let’s validate our understanding by comparing the VQF implementation with SciPy’s industry-standard implementation:</p>

<p><strong>Parameters:</strong></p>
<ul>
  <li>Sampling Frequency: 1000 Hz</li>
  <li>Cutoff Frequency: 100 Hz</li>
  <li>Filter Order: 2</li>
  <li>Nyquist Frequency: 500 Hz</li>
</ul>

<h3 id="52-coefficient-comparison">5.2 Coefficient Comparison</h3>

<p><strong>Method 1: SciPy Implementation</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b coefficients: [0.06745527 0.13491055 0.06745527]
a coefficients: [ 1.        -1.1429805  0.4128016]
</code></pre></div></div>

<p><strong>Method 2: VQF Implementation</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b coefficients: [0.06745527 0.13491055 0.06745527]
a coefficients: [ 1.        -1.1429805  0.4128016]
</code></pre></div></div>

<p><strong>Result:</strong> Perfect match! Both methods produce identical coefficients.</p>

<h3 id="53-frequency-response-analysis">5.3 Frequency Response Analysis</h3>

<p>The frequency response confirms:</p>
<ul>
  <li><strong>-3 dB cutoff</strong> exactly at 100 Hz</li>
  <li><strong>Passband flatness</strong> as expected</li>
  <li><strong>Roll-off rate</strong> of -40 dB/decade</li>
  <li><strong>No ripples</strong> in passband or stopband</li>
</ul>

<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q3/butterworth.png" alt="Butterworth Filter Frequency Response" align="center" class="center_img" />
<figcaption>Figure 1: Frequency response of the 2nd-order Butterworth low-pass filter showing the -3 dB cutoff at 100 Hz</figcaption>
</figure>

<h2 id="6-conclusion">6. Conclusion</h2>

<h3 id="61-key-takeaways">6.1 Key Takeaways</h3>

<ol>
  <li><strong>Mathematical Foundation</strong>: The Butterworth filter’s normalized prototype provides a solid starting point</li>
  <li><strong>Pre-warping Importance</strong>: Frequency compensation is crucial for accurate digital filter design</li>
  <li><strong>VQF Method Superiority</strong>: The VQF approach automatically handles pre-warping, making it more robust</li>
  <li><strong>Validation</strong>: Both theoretical and experimental results confirm the correctness of our implementation</li>
</ol>

<h3 id="62-practical-applications">6.2 Practical Applications</h3>

<p>This understanding is essential for:</p>
<ul>
  <li><strong>Sensor data processing</strong> in robotics and IoT</li>
  <li><strong>Audio signal filtering</strong> in consumer electronics</li>
  <li><strong>Control system design</strong> in automotive and aerospace</li>
  <li><strong>Biomedical signal processing</strong> in healthcare devices</li>
</ul>

<h3 id="63-further-reading">6.3 Further Reading</h3>

<p>For deeper exploration, consider:</p>
<ul>
  <li><a href="https://github.com/dlaidig/vqf">VQF IMU Attitude Fusion Algorithm</a> - The source of our implementation</li>
  <li><a href="https://stackoverflow.com/questions/20924868/calculate-coefficients-of-2nd-order-butterworth-low-pass-filter/52764064#52764064">Stack Overflow Discussion</a> - Detailed mathematical derivation</li>
  <li>Signal Processing textbooks on digital filter design</li>
</ul>

<p>The Butterworth filter remains a cornerstone of signal processing, and understanding its implementation details empowers engineers to create robust, efficient filtering solutions for real-world applications.</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="math" /><category term="algorithm" /><summary type="html"><![CDATA[From Theory to Implementation: A Comprehensive Guide to Butterworth Filters]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">4th-order Rugge-Kutta</title><link href="https://sunbingfeng.github.io/blog/RungeKutta/" rel="alternate" type="text/html" title="4th-order Rugge-Kutta" /><published>2025-04-25T00:00:00+00:00</published><updated>2025-04-25T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/RungeKutta</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/RungeKutta/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第6篇，介绍常见的4阶Runge-Kutta方法。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>在使用IMU的过程中，不可避免的需要对IMU原始数据做积分以获得位置和姿态角，那么Runge-Kutta方法就是一个绕不过去的知识点。相比于基础的中值积分等，可以提升积分的精度。</p>

<h2 id="ask-the-ai">Ask the AI</h2>

<p>让AI给我编写4阶Runge-Kutta方法的过程中，其多次给我反馈带错误的实现，搞得我血压飙升，忍不住骂AI了。其间，AI一个劲的给我道歉，也是挺搞笑的。</p>

<blockquote>

  <p>I apologize for my previous incorrect responses. You’re right - I should be more careful and verify the formulas before suggesting changes.</p>

</blockquote>

<p>不知道是把他骂晕了，还是怎么着，几个公式的符号就是死活搞不对。最后还是得我自己一行一行检查，一个一个符号确认，才让程序可以正常工作。</p>

<p>所以，这次就不附上问AI的过程了，直接上最终能工作的版本，以免大家也同我一样闹心，心率失常。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rk4_integration</span><span class="p">(</span><span class="n">gyro_data</span><span class="p">,</span> <span class="n">acc_data</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Perform 4th-order Runge-Kutta integration on IMU data.
    
    Args:
        gyro_data: numpy array of gyroscope data (N x 3) in rad/s
        acc_data: numpy array of accelerometer data (N x 3) in m/s^2
        dt: time step in seconds
        initial_state: initial state [x, y, z, vx, vy, vz, qw, qx, qy, qz]
                      (position, velocity, quaternion)
    
    Returns:
        states: numpy array of integrated states (N x 10)
    </span><span class="sh">"""</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">gyro_data</span><span class="p">)</span>
    
    <span class="c1"># Initialize state vector [x, y, z, vx, vy, vz, qw, qx, qy, qz]
</span>    <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        
        <span class="n">initial_state</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        
    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">vel_dot</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_state</span>
    
    <span class="k">def</span> <span class="nf">state_derivative</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">gyro</span><span class="p">,</span> <span class="n">acc</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Calculate state derivatives for IMU integration.
        state: [x, y, z, vx, vy, vz, qw, qx, qy, qz]
        </span><span class="sh">"""</span>
        <span class="c1"># Extract quaternion
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q_norm</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Warning: Quaternion norm is too small!</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            
        <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">/</span> <span class="n">q_norm</span>  <span class="c1"># Normalize quaternion
</span>        
        <span class="n">qw</span><span class="p">,</span> <span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">q</span>
        <span class="c1"># Quaternion derivative from gyroscope
</span>        <span class="n">wx</span><span class="p">,</span> <span class="n">wy</span><span class="p">,</span> <span class="n">wz</span> <span class="o">=</span> <span class="n">gyro</span>
        <span class="n">q_dot</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
            <span class="p">[</span><span class="o">-</span><span class="n">qx</span><span class="o">*</span><span class="n">wx</span> <span class="o">-</span> <span class="n">qy</span><span class="o">*</span><span class="n">wy</span> <span class="o">-</span> <span class="n">qz</span><span class="o">*</span><span class="n">wz</span><span class="p">],</span>
            <span class="p">[</span> <span class="o">-</span><span class="n">qw</span><span class="o">*</span><span class="n">wx</span> <span class="o">-</span> <span class="n">qz</span><span class="o">*</span><span class="n">wy</span> <span class="o">+</span> <span class="n">qy</span><span class="o">*</span><span class="n">wz</span><span class="p">],</span>
            <span class="p">[</span> <span class="n">qz</span><span class="o">*</span><span class="n">wx</span> <span class="o">+</span> <span class="n">qw</span><span class="o">*</span><span class="n">wy</span> <span class="o">-</span> <span class="n">qx</span><span class="o">*</span><span class="n">wz</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="n">qy</span><span class="o">*</span><span class="n">wx</span> <span class="o">+</span> <span class="n">qx</span><span class="o">*</span><span class="n">wy</span> <span class="o">+</span> <span class="n">qw</span><span class="o">*</span><span class="n">wz</span><span class="p">]</span>
        <span class="p">]).</span><span class="nf">flatten</span><span class="p">()</span>
       
        <span class="c1"># Rotation matrix from quaternion
</span>        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qy</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qz</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">qx</span><span class="o">*</span><span class="n">qy</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qw</span><span class="o">*</span><span class="n">qz</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">qx</span><span class="o">*</span><span class="n">qz</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">qw</span><span class="o">*</span><span class="n">qy</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">qx</span><span class="o">*</span><span class="n">qy</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">qw</span><span class="o">*</span><span class="n">qz</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qx</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qz</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">qy</span><span class="o">*</span><span class="n">qz</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qw</span><span class="o">*</span><span class="n">qx</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">qx</span><span class="o">*</span><span class="n">qz</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qw</span><span class="o">*</span><span class="n">qy</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">qy</span><span class="o">*</span><span class="n">qz</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">qw</span><span class="o">*</span><span class="n">qx</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qx</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">qy</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">])</span>
        
        <span class="c1"># Check if rotation matrix is valid
</span>        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">isnan</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        
        <span class="c1"># Accelerometer measurement in world frame
</span>        <span class="n">acc_world</span> <span class="o">=</span> <span class="n">R</span> <span class="o">@</span> <span class="n">acc</span>
        
        <span class="c1"># Check if acceleration is valid
</span>        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">isnan</span><span class="p">(</span><span class="n">acc_world</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        
        <span class="c1"># State derivative
</span>        <span class="n">state_dot</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">state_dot</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># Position derivative = velocity
</span>        <span class="n">state_dot</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc_world</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">9.81</span><span class="p">])</span>  <span class="c1"># Velocity derivative = acceleration - gravity
</span>        <span class="n">state_dot</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_dot</span>  <span class="c1"># Quaternion derivative
</span>        
        <span class="c1"># print("velocity derivative: ", state_dot[3:6]) 
</span>        <span class="k">return</span> <span class="n">state_dot</span>
    
    <span class="c1"># RK4 integration
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gyro</span> <span class="o">=</span> <span class="n">gyro_data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">acc_data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Check input data
</span>        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">isnan</span><span class="p">(</span><span class="n">gyro</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">isnan</span><span class="p">(</span><span class="n">acc</span><span class="p">)):</span>
            <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Keep previous state
</span>            <span class="k">continue</span>
        
        <span class="c1"># RK4 steps
</span>        <span class="n">k1</span> <span class="o">=</span> <span class="nf">state_derivative</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">gyro</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="nf">state_derivative</span><span class="p">(</span><span class="n">state</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">gyro</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="nf">state_derivative</span><span class="p">(</span><span class="n">state</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">k2</span><span class="p">,</span> <span class="n">gyro</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="nf">state_derivative</span><span class="p">(</span><span class="n">state</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">k3</span><span class="p">,</span> <span class="n">gyro</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
        
        <span class="c1"># Update state
</span>        <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span> <span class="o">+</span> <span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span>
        
        <span class="c1"># Normalize quaternion
</span>        <span class="n">q_norm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">q_norm</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Warning: Quaternion norm too small at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Keep previous state
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">/</span> <span class="n">q_norm</span>
        
        <span class="n">vel_dot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k4</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">vel_dot</span>
</code></pre></div></div>

<p>不过有一说一，AI的思路还是相当清晰的，逻辑可圈可点。
其针对IMU积分过程，首先定义了状态变量，明确了一阶导的实现，然后指出RK4算法所需要的4步微分中间量，最后汇总积分输出更新后的状态量。
整个过程很清晰，一眼就能很清楚每一步在干啥。</p>

<p>所以，一句话总结一下这一次跟AI聊天的经验。那就是，框架性的东西问AI，细节性的东西还是得自己细心检查。</p>

<h2 id="experiments">Experiments</h2>

<p>下面，我们用一段IMU的数据，做一个简单的测试。测试代码以及所使用的测试数据详见评论区。</p>

<p>我们看一下IMU的数据情况：</p>
<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q2/gyro.png" alt="img" align="center" class="center_img" />
</figure>
<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q2/acc.png" alt="img" align="center" class="center_img" />
</figure>

<p>接下来就是RK4积分后的结果：</p>
<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q2/result.png" alt="img" align="center" class="center_img" />
</figure>

<p>好了，感兴趣的朋友可以去体验一下。</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="algorithm" /><summary type="html"><![CDATA[AI Chat Series]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Fast Inverse sqrt</title><link href="https://sunbingfeng.github.io/blog/fast_inv_sqrt/" rel="alternate" type="text/html" title="Fast Inverse sqrt" /><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/fast_inv_sqrt</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/fast_inv_sqrt/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第5篇，介绍一种快速的\(\frac{1}{\sqrt{x}}\)求解算法。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>在嵌入式平台上，经常需要优化算法的执行效率。今天介绍一种快速的求解inverse sqrt的方法。这个经典的快速求解算法，于1999年首次应用于一款第一人称视角游戏 <strong>Quake III Arena</strong> 中。其中涉及到大量的向量normalization运算，也即除以向量模的操作。通过该算法的应用，极大的提升了游戏的性能。一个小的优化，收获数量级的性能提升，堪称算法优化的典范。</p>

<h2 id="ask-the-ai">Ask the AI</h2>

<blockquote>
  <p>Me: Help me to implement a fast inverse sqrt method.</p>

  <p>AI: I’ll help you implement the famous “Fast Inverse Square Root” algorithm, which was popularized by Quake III Arena. This algorithm provides a fast approximation of \(\frac{1}{\sqrt{x}}\).</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">FastInverseSqrt</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Evil floating point bit hack</span>
    <span class="kt">float</span> <span class="n">xhalf</span> <span class="o">=</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>              <span class="c1">// Reinterpret float bits as int</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>      <span class="c1">// The magic number</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>                <span class="c1">// Reinterpret int bits as float</span>
    
    <span class="c1">// Newton's method iteration for better accuracy</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5f</span> <span class="o">-</span> <span class="n">xhalf</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// First iteration</span>
    <span class="c1">// x = x * (1.5f - xhalf * x * x); // Optional: Second iteration for more accuracy</span>
    
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For a more modern C++ implementation with type safety:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
</span>
<span class="kt">float</span> <span class="nf">FastInverseSqrt</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">conv</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="n">xhalf</span> <span class="o">=</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">conv</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">conv</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span><span class="n">conv</span><span class="p">.</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">conv</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5f</span> <span class="o">-</span> <span class="n">xhalf</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// First Newton iteration</span>
    <span class="c1">// x = x * (1.5f - xhalf * x * x); // Optional: Second iteration</span>
    
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="how-it-works">How it works:</h3>

<ol>
  <li>
    <p><strong>Bit manipulation</strong>: The algorithm exploits the IEEE 754 floating-point representation to approximate \(\log_2\) through integer operations.</p>
  </li>
  <li>
    <p><strong>Magic number</strong>: 0x5f3759df is a carefully chosen constant that helps approximate the logarithm.</p>
  </li>
  <li>
    <p><strong>Newton’s method</strong>: One or two iterations of Newton’s method refine the approximation.</p>
  </li>
</ol>

<h3 id="usage-example">Usage example:</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">inv_sqrt</span> <span class="o">=</span> <span class="n">FastInverseSqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="c1">// inv_sqrt ≈ 1/√2 ≈ 0.707106781</span>
</code></pre></div></div>

<h3 id="performance-comparison">Performance comparison:</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Standard library version</span>
<span class="kt">float</span> <span class="nf">StandardInverseSqrt</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Benchmark example</span>
<span class="kt">void</span> <span class="nf">CompareSpeed</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
    
    <span class="c1">// Fast version</span>
    <span class="kt">float</span> <span class="n">fast_result</span> <span class="o">=</span> <span class="n">FastInverseSqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    
    <span class="c1">// Standard version</span>
    <span class="kt">float</span> <span class="n">std_result</span> <span class="o">=</span> <span class="n">StandardInverseSqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    
    <span class="c1">// Compare accuracy</span>
    <span class="kt">float</span> <span class="n">relative_error</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">fast_result</span> <span class="o">-</span> <span class="n">std_result</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_result</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Relative error: %e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">relative_error</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="notes">Notes:</h3>

<ol>
  <li>
    <p><strong>Accuracy</strong>: The fast version is an approximation. One Newton iteration gives about 1% accuracy, two iterations about 0.1%.</p>
  </li>
  <li>
    <p><strong>Modern hardware</strong>: On modern CPUs, the standard <code class="language-plaintext highlighter-rouge">1.0f / std::sqrt(x)</code> might be just as fast due to hardware optimizations.</p>
  </li>
  <li>
    <p><strong>Undefined behavior</strong>: The original bit-hack version technically violates strict aliasing rules. The union version is safer.</p>
  </li>
  <li>
    <p><strong>Positive numbers</strong>: The function assumes positive input numbers.</p>
  </li>
</ol>

<p>If you need a specific accuracy level or have other requirements, let me know and I can modify the implementation accordingly.</p>

<p>这是基于CPP的实现，关于其背后的理论知识以及详细的推导过程，建议查看<a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">Wikipedia</a>上的解释，非常的详细。
接下来，我们让AI写一个Python的实现，并编写相关的测试benchmark。</p>

<blockquote>
  <p>Me: Re-implement it in Python please.</p>

  <p>AI: Here’s the Fast Inverse Square Root implementation in Python, using both NumPy for vectorized operations and a pure Python version:</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">struct</span>

<span class="k">def</span> <span class="nf">fast_inverse_sqrt_single</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Fast inverse square root for a single float number
    Args:
        x: Input float number (must be positive)
    Returns:
        Approximation of 1/sqrt(x)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Input must be positive</span><span class="sh">"</span><span class="p">)</span>
    
    <span class="c1"># Convert float to its binary representation
</span>    <span class="n">x_bytes</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">,</span> <span class="n">x_bytes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># The magic number and bit manipulation
</span>    <span class="n">x_half</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Convert back to float
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">,</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">,</span> <span class="n">i</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Newton iteration
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">-</span> <span class="n">x_half</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># First iteration
</span>    <span class="c1"># x = x * (1.5 - x_half * x * x)  # Optional: Second iteration for more accuracy
</span>    
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">fast_inverse_sqrt_numpy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Vectorized fast inverse square root for numpy arrays
    Args:
        x: Input numpy array (must be positive)
    Returns:
        Array with approximations of 1/sqrt(x)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">All inputs must be positive</span><span class="sh">"</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">x_half</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span>
    
    <span class="c1"># View float32 as int32 for bit manipulation
</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="c1"># Newton iteration
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">-</span> <span class="n">x_half</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># First iteration
</span>    <span class="c1"># x = x * (1.5 - x_half * x * x)  # Optional: Second iteration
</span>    
    <span class="k">return</span> <span class="n">x</span>

<span class="c1"># Example usage and testing
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="c1"># Test single value
</span>    <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">result_single</span> <span class="o">=</span> <span class="nf">fast_inverse_sqrt_single</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">true_value</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Single value test:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Input: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Fast inverse sqrt: </span><span class="si">{</span><span class="n">result_single</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">True value: </span><span class="si">{</span><span class="n">true_value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Relative error: </span><span class="si">{</span><span class="nf">abs</span><span class="p">(</span><span class="n">result_single</span> <span class="o">-</span> <span class="n">true_value</span><span class="p">)</span> <span class="o">/</span> <span class="n">true_value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    
    <span class="c1"># Test numpy array
</span>    <span class="n">x_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">result_array</span> <span class="o">=</span> <span class="nf">fast_inverse_sqrt_numpy</span><span class="p">(</span><span class="n">x_array</span><span class="p">)</span>
    <span class="n">true_array</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">x_array</span><span class="p">)</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">Array test:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Input array: </span><span class="si">{</span><span class="n">x_array</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Fast inverse sqrt: </span><span class="si">{</span><span class="n">result_array</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">True values: </span><span class="si">{</span><span class="n">true_array</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Relative errors: </span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">result_array</span> <span class="o">-</span> <span class="n">true_array</span><span class="p">)</span> <span class="o">/</span> <span class="n">true_array</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    
    <span class="c1"># Benchmark
</span>    <span class="kn">import</span> <span class="n">time</span>
    
    <span class="n">size</span> <span class="o">=</span> <span class="mi">1000000</span>
    <span class="n">x_large</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">(</span><span class="n">size</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    <span class="n">fast_result</span> <span class="o">=</span> <span class="nf">fast_inverse_sqrt_numpy</span><span class="p">(</span><span class="n">x_large</span><span class="p">)</span>
    <span class="n">fast_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    <span class="n">numpy_result</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">x_large</span><span class="p">)</span>
    <span class="n">numpy_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">Benchmark:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Fast inverse sqrt time: </span><span class="si">{</span><span class="n">fast_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Numpy time: </span><span class="si">{</span><span class="n">numpy_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Mean relative error: </span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">fast_result</span> <span class="o">-</span> <span class="n">numpy_result</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy_result</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>This implementation provides:</p>

<ol>
  <li><strong>Single Value Function</strong>: <code class="language-plaintext highlighter-rouge">fast_inverse_sqrt_single()</code>
    <ul>
      <li>Works with individual float values</li>
      <li>Uses Python’s <code class="language-plaintext highlighter-rouge">struct</code> module for bit manipulation</li>
    </ul>
  </li>
  <li><strong>Vectorized Function</strong>: <code class="language-plaintext highlighter-rouge">fast_inverse_sqrt_numpy()</code>
    <ul>
      <li>Works with NumPy arrays</li>
      <li>Vectorized operations for better performance</li>
      <li>Uses NumPy’s view casting for bit manipulation</li>
    </ul>
  </li>
  <li><strong>Testing and Benchmarking</strong>:
    <ul>
      <li>Compares results with true values</li>
      <li>Measures performance against NumPy’s implementation</li>
      <li>Calculates relative errors</li>
    </ul>
  </li>
</ol>

<p>Key features:</p>
<ul>
  <li>Type checking and error handling</li>
  <li>Both scalar and vectorized implementations</li>
  <li>Performance benchmarking</li>
  <li>Accuracy comparison with true values</li>
</ul>

<p>Note that in Python, this implementation is mainly for educational purposes because:</p>
<ol>
  <li>NumPy’s <code class="language-plaintext highlighter-rouge">1.0 / np.sqrt(x)</code> is highly optimized</li>
  <li>Python’s overhead makes bit manipulation less efficient than in C/C++</li>
  <li>Modern hardware often has fast floating-point operations</li>
</ol>

<p>The vectorized NumPy version will be much faster than the single-value version for large arrays, but might still be slower than NumPy’s built-in functions.</p>

<h2 id="experiments">Experiments</h2>

<p>首先，我们来运行一下Python的版本，看下结果如何：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Single value <span class="nb">test</span>:
Input: 2.0
Fast inverse sqrt: 0.7069300386983334
True value: 0.7071067811865475
Relative error: 0.00024995162387992986

Array <span class="nb">test</span>:
Input array: <span class="o">[</span> 1.  2.  4. 16.]
Fast inverse sqrt: <span class="o">[</span>0.99830717 0.70693004 0.49915358 0.24957679]
True values: <span class="o">[</span>1.         0.70710677 0.5        0.25      <span class="o">]</span>
Relative errors: <span class="o">[</span>0.00169283 0.00024993 0.00169283 0.00169283]

Benchmark:
Fast inverse sqrt <span class="nb">time</span>: 0.009000 seconds
Numpy <span class="nb">time</span>: 0.002001 seconds
Mean relative error: 0.0009781228145584464
</code></pre></div></div>

<p>从上面的结果来看，快速invsqrt算法的逼近误差约在小数点后3位，精度还不错。单次耗时约0.009s，大于Numpy的0.002s。看来AI说的没错，Numpy中的实现做了向量化操作相关的优化，因此耗时更低。
下面我们换到嵌入式平台上来验证。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">/// DEBUG CODE</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">60000000</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
    <span class="n">wlt</span><span class="o">::</span><span class="n">TicToc</span> <span class="n">timer</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">invSqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">LOG</span><span class="p">(</span><span class="s">"invSqrt time: %.3f, sum: %.3f</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">timer</span><span class="p">.</span><span class="n">toc</span><span class="p">(),</span> <span class="n">sum</span><span class="p">);</span>
    <span class="n">timer</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>

    <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">LOG</span><span class="p">(</span><span class="s">"inv sqrt throuth 1/sqrt time: %.3f, sum: %.3f</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">timer</span><span class="p">.</span><span class="n">toc</span><span class="p">(),</span> <span class="n">sum</span><span class="p">);</span>
</code></pre></div></div>

<p>结果如下所示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>invSqrt time: 5779.0, sum: 8192.0

inv sqrt throuth 1/sqrt time: 13174.0, sum: 8192.0
</code></pre></div></div>

<p>上面的耗时是N次的总耗时，平均后可以发现, 快速invsqrt单次执行耗时约96ns，1/sqrt耗时约为220ns，降低了1倍多，优化还是很明显的。</p>

<p>但是，这个耗时在ns数量级，如果invsqrt调用频次较低的话，这个耗时优化几乎无感！！因此，大家务必根据自己的应用场景合理选择。</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="math" /><category term="tips" /><summary type="html"><![CDATA[AI Chat Series]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Conjugate Gradient Method</title><link href="https://sunbingfeng.github.io/blog/Congugate_Gradient/" rel="alternate" type="text/html" title="Conjugate Gradient Method" /><published>2025-04-11T00:00:00+00:00</published><updated>2025-04-11T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/Congugate_Gradient</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/Congugate_Gradient/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第4篇，介绍基于Conjugate Gradient的线性求解方法。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>在优化求解问题中，经常会碰到类似\(Ax=b\)的线性方程求解问题。如果A是对称矩阵，那么可以调用常规的LU分解或者Cholskey分解来完成方程式的求解。</p>

<p>这类求解方法没啥好说的，今天来介绍一个基于迭代的求解方法。正如文章标题所述，该方法主要基于Conjugate Gradient，下面基于AI的配合，详细阐述一下。</p>

<h2 id="ask-the-ai">Ask the AI</h2>

<blockquote>
  <p>Me: Responding to Ax=b problems where A is large and sparse, direct methods, i.e, LU decomposition, are computationally expensive. Can you show me how to solve it through Conjugate Gradient method?</p>

  <p>AI: Certainly! Iterative methods are particularly useful for solving large systems of linear equations, especially when the matrix involved is sparse or too large for direct methods to be efficient. One of the most common iterative methods for solving systems of linear equations is the <strong>Conjugate Gradient (CG) method</strong>. Here’s a more detailed explanation:</p>
</blockquote>

<p>The Conjugate Gradient (CG) method is an iterative algorithm for solving systems of linear equations \(Ax = b\), where \(A\) is a symmetric positive definite matrix. Here’s a step-by-step derivation of the method:</p>

<h3 id="problem-setup"><strong>Problem Setup:</strong></h3>

<p>Given a symmetric positive definite matrix \(A\) and a vector \(b\), we want to find the vector \(x\) that minimizes the quadratic function:</p>

\[f(x) = \frac{1}{2} x^T A x - b^T x\]

<p>The gradient of this function is:</p>

\[\nabla f(x) = Ax - b\]

<p>Setting the gradient to zero gives the system of equations:</p>

\[Ax = b\]

<h3 id="derivation-of-the-cg-method"><strong>Derivation of the CG Method:</strong></h3>

<ol>
  <li><strong>Initialization</strong>:
    <ul>
      <li>Start with an initial guess \(x_0\).</li>
      <li>Compute the initial residual \(r_0 = b - Ax_0\).</li>
      <li>Set the initial search direction \(p_0 = r_0\).</li>
    </ul>
  </li>
  <li><strong>Iterative Process</strong>:
    <ul>
      <li>For each iteration \(k\), perform the following steps:</li>
    </ul>
  </li>
  <li><strong>Compute Step Size</strong>:
    <ul>
      <li>Calculate the step size \(\alpha_k\) using the formula:</li>
    </ul>

\[\alpha_k = \frac{r_k^T r_k}{p_k^T A p_k}\]
  </li>
  <li><strong>Update the Solution</strong>:
    <ul>
      <li>Update the solution vector \(x\):</li>
    </ul>

\[x_{k+1} = x_k + \alpha_k p_k\]
  </li>
  <li><strong>Update the Residual</strong>:
    <ul>
      <li>Compute the new residual:</li>
    </ul>

\[r_{k+1} = r_k - \alpha_k A p_k\]
  </li>
  <li><strong>Check for Convergence</strong>:
    <ul>
      <li>If the norm of the residual \(r_{k+1}\) is below a certain threshold, the algorithm has converged.</li>
    </ul>
  </li>
  <li><strong>Compute the New Search Direction</strong>:
    <ul>
      <li>Calculate the coefficient \(\beta_k\):</li>
    </ul>

\[\beta_k = \frac{r_{k+1}^T r_{k+1}}{r_k^T r_k}\]
  </li>
  <li><strong>Update the Search Direction</strong>:
    <ul>
      <li>Update the search direction:</li>
    </ul>

\[p_{k+1} = r_{k+1} + \beta_k p_k\]
  </li>
</ol>

<h3 id="convergence">Convergence:</h3>

<p>The CG method converges in at most \(n\) iterations for an \(n \times n\) matrix, but it often converges much faster in practice. The method is efficient because it only requires matrix-vector multiplications and does not need to store the entire matrix \(A\).</p>

<h3 id="summary">Summary:</h3>

<p>The Conjugate Gradient method is powerful for solving large, sparse systems of linear equations due to its efficiency and the fact that it only requires the matrix \(A\) to be symmetric and positive definite. The method iteratively refines the solution by minimizing the quadratic form associated with the system, using conjugate directions to ensure convergence.</p>

<p>这里需要补充说明一下，\(\alpha_k\) 为什么取这个值，继续跟AI聊一下。</p>

<blockquote>
  <p>Me: I think the derivation of the update of the \(\alpha_k\) might be to minimize the quadratic test function \(\frac{1}{2}x^T A x - x^T b\). Through this way, I can obtain the specified formula \(\alpha_k\) What’s your opinion?</p>

  <p>AI: Yes, you’re absolutely right! The correct way to derive \(\alpha_k\) is through minimizing the quadratic objective function. Let me show the correct derivation:</p>
</blockquote>

<h3 id="correct-derivation-of-alpha_k">Correct Derivation of \(\alpha_k\)</h3>

<p>The quadratic objective function is:</p>

\[f(x) = \frac{1}{2}x^T A x - x^T b\]

<ol>
  <li><strong>Update Step</strong>:
    <ul>
      <li>At each iteration, we update \(x\) along the search direction:</li>
    </ul>

\[x_{k+1} = x_k + \alpha_k p_k\]
  </li>
  <li><strong>Minimizing the Objective Function</strong>:
    <ul>
      <li>Substitute the update into the objective function:</li>
    </ul>

\[f(x_k + \alpha_k p_k) = \frac{1}{2}(x_k + \alpha_k p_k)^T A (x_k + \alpha_k p_k) - (x_k + \alpha_k p_k)^T b\]
  </li>
  <li><strong>Take Derivative with Respect to \(\alpha_k\)</strong>:
    <ul>
      <li>Set the derivative to zero:</li>
    </ul>

\[\frac{d}{d\alpha_k}f(x_k + \alpha_k p_k) = p_k^T A x_k + \alpha_k p_k^T A p_k - p_k^T b = 0\]
  </li>
  <li><strong>Using the Residual</strong>:
    <ul>
      <li>Note that \(r_k = b - A x_k\)</li>
      <li>Therefore, \(p_k^T(b - A x_k) = p_k^T r_k\)</li>
    </ul>
  </li>
  <li>
    <p><strong>Solve for \(\alpha_k\)</strong>:</p>

\[\alpha_k = \frac{p_k^T r_k}{p_k^T A p_k} = \frac{r_k^T r_k}{p_k^T A p_k}\]
  </li>
</ol>

<p>This derivation through minimizing the quadratic objective function gives us the correct formula for \(\alpha_k\). This approach is more principled than trying to minimize \(r_{k+1}^2\) directly, as it aligns with the fundamental goal of the Conjugate Gradient method: finding the minimum of the quadratic form.</p>

<p>The last equality \(\frac{p_k^T r_k}{p_k^T A p_k} = \frac{r_k^T r_k}{p_k^T A p_k}\) holds because at each iteration, \(p_k\) is a linear combination of \(r_k\) and previous search directions.</p>

<p>This derivation helps explain why the Conjugate Gradient method is so effective at minimizing the quadratic objective function and solving the linear system \(Ax = b\).</p>

<p>补充说明一下，二次代价函数\(f(x_k)\)的一阶导为\(A x_k - b\)，而CG求解过程中所谓的残差\(r_k=b - A x_k\)其实就是负梯度方向。\(x_{k+1}\)更新是沿着\(p_k\)方向更新\(\alpha_k\)步进，该本质就是沿着负梯度方向的线性搜索。\(p_0\)初始值选择就是\(r_0\)的方向，\(p_{k+1}\)更新基于\(r_{k+1}\)和\(p_k\)的线性组合，因此可以近似认为\(p_k\)还是沿着负梯度方向，也即与\(r_k\)同向。</p>

<blockquote>
  <p>Me: Can you give me more theory support to this method?</p>

  <p>AI: Yes, the Conjugate Gradient (CG) method is supported by several theoretical foundations that explain its efficiency and convergence properties. Here are some key theoretical aspects:</p>
</blockquote>

<h3 id="krylov-subspace-methods"><strong>Krylov Subspace Methods</strong></h3>

<p>The CG method is a type of Krylov subspace method. These methods iteratively build a solution by exploring the Krylov subspace, which is generated by the initial residual and the matrix \(A\):</p>

\[\mathcal{K}_k(A, r_0) = \text{span}\{r_0, Ar_0, A^2r_0, \ldots, A^{k-1}r_0\}\]

<p>The CG method finds the best approximation to the solution within this subspace, minimizing the error in the \(A\)-norm.</p>

<h3 id="conjugate-directions"><strong>Conjugate Directions</strong></h3>

<p>The method constructs a sequence of search directions that are \(A\)-conjugate, meaning they satisfy:</p>

\[p_i^T A p_j = 0 \quad \text{for} \quad i \neq j\]

<p>This property ensures that each step in the algorithm is orthogonal to the previous ones in the transformed space defined by \(A\), leading to efficient convergence.</p>

<h3 id="quadratic-minimization"><strong>Quadratic Minimization</strong></h3>

<p>The CG method minimizes the quadratic form:</p>

\[f(x) = \frac{1}{2} x^T A x - b^T x\]

<p>By iteratively updating the solution, the method reduces the residual and the error in the solution, converging to the minimum of the quadratic form.</p>

<h3 id="convergence-properties"><strong>Convergence Properties</strong></h3>

<ul>
  <li><strong>Finite Termination</strong>: For an \(n \times n\) matrix, the CG method converges in at most \(n\) iterations, assuming exact arithmetic. In practice, it often converges much faster.</li>
  <li><strong>Error Reduction</strong>: The error in the solution decreases exponentially with each iteration, especially when the eigenvalues of \(A\) are well-clustered.</li>
</ul>

<h3 id="spectral-properties"><strong>Spectral Properties</strong></h3>

<p>The convergence rate of the CG method is influenced by the eigenvalues of the matrix \(A\). The method converges faster when the eigenvalues are tightly clustered, as this leads to a smaller condition number.</p>

<h3 id="preconditioning"><strong>Preconditioning</strong></h3>

<p>To improve convergence, preconditioning can be applied. A preconditioner \(M\) is used to transform the system into one with more favorable spectral properties:</p>

\[M^{-1}Ax = M^{-1}b\]

<p>The preconditioned system has a better-conditioned matrix, leading to faster convergence.</p>

<p>These theoretical foundations explain why the CG method is effective for solving large, sparse systems of linear equations, particularly when the matrix is symmetric and positive definite. The method’s reliance on conjugate directions and its ability to minimize the quadratic form efficiently are key to its success.</p>

<blockquote>
  <p>Me: Show me why \(p_i^T A p_j = 0\) applies.</p>

  <p>AI: The property \(p_i^T A p_j = 0\) for \(i \neq j\) in the Conjugate Gradient method is known as the conjugacy of the search directions. This property is crucial for the efficiency and convergence of the method. Let’s go through the reasoning behind this property.</p>
</blockquote>

<h3 id="conjugacy-of-search-directions">Conjugacy of Search Directions</h3>

<p>The search directions \(p_k\) in the Conjugate Gradient method are constructed to be \(A\)-conjugate, meaning:</p>

\[p_i^T A p_j = 0 \quad \text{for} \quad i \neq j\]

<h4 id="derivation">Derivation</h4>

<ol>
  <li><strong>Initialization</strong>:
    <ul>
      <li>The first search direction is set to the initial residual: \(p_0 = r_0\).</li>
    </ul>
  </li>
  <li><strong>Iterative Update</strong>:
    <ul>
      <li>For each iteration \(k\), the new search direction is computed as:</li>
    </ul>

\[p_{k+1} = r_{k+1} + \beta_k p_k\]

    <p>where</p>

\[\beta_k = \frac{r_{k+1}^T r_{k+1}}{r_k^T r_k}\]
  </li>
  <li><strong>Orthogonality of Residuals</strong>:
    <ul>
      <li>The residuals are orthogonal: \(r_i^T r_j = 0\) for \(i \neq j\).</li>
    </ul>
  </li>
  <li><strong>Conjugacy Proof</strong>:
    <ul>
      <li>Assume \(p_0, p_1, \ldots, p_k\) are \(A\)-conjugate.</li>
      <li>We need to show that \(p_{k+1}\) is also \(A\)-conjugate to all previous directions.</li>
    </ul>

    <p>Consider \(p_{k+1} = r_{k+1} + \beta_k p_k\). We want to show:</p>

\[p_{k+1}^T A p_j = 0 \quad \text{for} \quad j \leq k\]

    <ul>
      <li>
        <p>For \(j = k\):</p>

\[p_{k+1}^T A p_k = (r_{k+1} + \beta_k p_k)^T A p_k = r_{k+1}^T A p_k + \beta_k p_k^T A p_k\]

        <p>Since \(r_{k+1}\) is orthogonal to \(p_k\) in the \(A\)-norm, \(r_{k+1}^T A p_k = 0\). Also, by the definition of \(\beta_k\), the term \(\beta_k p_k^T A p_k\) does not affect the conjugacy.</p>
      </li>
      <li>
        <p>For \(j &lt; k\):</p>

\[p_{k+1}^T A p_j = (r_{k+1} + \beta_k p_k)^T A p_j = r_{k+1}^T A p_j + \beta_k p_k^T A p_j\]

        <p>Both terms are zero because \(r_{k+1}\) is orthogonal to all previous directions and \(p_k\) is \(A\)-conjugate to \(p_j\).</p>
      </li>
    </ul>
  </li>
</ol>

<h3 id="conclusion">Conclusion</h3>

<p>The conjugacy of the search directions ensures that each update in the Conjugate Gradient method is independent of the others in terms of the \(A\)-norm. This property is crucial for the method’s efficiency, allowing it to converge in at most \(n\) iterations for an \(n \times n\) matrix.</p>

<p>上面AI给出的解释，我始终觉得有问题，就是这一段：</p>

<blockquote>
  <p>Since \(r_{k+1}\) is orthogonal to \(p_k\) in the \(A\)-norm, \(r_{k+1}^T A p_k = 0\). Also, by the definition of \(\beta_k\), the term \(\beta_k p_k^T A p_k\) does not affect the conjugacy.</p>
</blockquote>

<p>\(r_{k+1}\)与\(r_k\)是正交的，而\(r_{k+1}=r_{k}-\alpha_{k}Ap_{k}\)，也即其可以由\(r_k\)和\(A p_k\)线性表达，因此\(r_{k+1}\)不可能与\(Ap_{k}\)正交。再者，\(p_k^T A p_k\)是大于0的，它怎么就不影响\(p_{k+1}\)的conjugacy特性，怎么就能推出\(p_{k+1}^T A p_k=0\)？</p>

<p>反正AI的解释就是糊里糊涂的。下面我来推导一下\(\beta\)的由来，以说明为啥前后\(p_{k}\)是conjugate orthogonal。</p>

<p>Congugate Gradient的核心宗旨是确保\(p_{k+1}^T A p_k=0\), 那么:</p>

\[\begin{align}
(r_{k+1} + \beta A p_{k})^T A p_{k} = 0 \\
r_{k+1}^T A p_k + \beta p_{k}^T A p_k = 0 \\
\beta = -\frac{r_{k+1}^T A p_k}{p_k^T A p_k} \\
\end{align}\]

<p>由前面的推导可知：</p>

\[\begin{align}
r_{k+1} = r_k - \alpha_k A p_k \\
\alpha_k = \frac{r_k^T r_k}{p_k^T A p_k}
\end{align}\]

<p>代入到前面的公式可得：</p>

\[\beta = -\frac{r_{k+1}^T(r_k - r_{k+1})}{\alpha {p_k^T A p_k}}
= \frac{r_{k+1}^T r_{k+1}}{r_k^T r_k}\]

<p>因此，\(\beta\)的特殊取值设计保证了\(p_{k}\)是conjugate orthogonal。</p>

<h2 id="experiments">Experiments</h2>

<p>好了，说里那么多，我们来写一段测试程序验证下该方法的可行性。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_conjugate_gradient</span><span class="p">():</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">J</span><span class="p">)</span>
    <span class="n">x_true</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x_true</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">x_true: </span><span class="sh">"</span><span class="p">,</span> <span class="n">x_true</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">x: </span><span class="sh">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="sh">"</span><span class="s">, error: </span><span class="sh">"</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_true</span><span class="p">))</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">r_old</span> <span class="o">=</span> <span class="n">r</span>
    
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">Ap</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Ap</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">p</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">Ap</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">r_old</span><span class="p">,</span> <span class="n">r_old</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">p</span>
        <span class="n">r_old</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">errors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_true</span><span class="p">))</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">x by CG: </span><span class="sh">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="sh">"</span><span class="s">, error: </span><span class="sh">"</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_true</span><span class="p">))</span>
    
    <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">"</span><span class="s">conjugate gradient error</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>

<p>这段测试程序很简单，就是生成一个随机的10x10的方阵J，然后构造对称矩阵A。针对给定的x值，生成对应的b，然后通过两种方法（一为numpy内置的线性求解器，二为上面介绍的Conjugate Gradient方法）求解x的估计值。</p>

<p>运行结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x_true:  [0.43035432 0.64106726 0.0515147  0.03762809 0.73804567 0.23480996
 0.76863671 0.14293322 0.3014281  0.21103692]
x:  [0.43035432 0.64106726 0.0515147  0.03762809 0.73804567 0.23480996        
 0.76863671 0.14293322 0.3014281  0.21103692] , error:  8.102494088942738e-14 
x by CG:  [0.43035432 0.64106726 0.0515147  0.03762809 0.73804567 0.23480996  
 0.76863671 0.14293322 0.3014281  0.21103692] , error:  2.7416374433878263e-11
</code></pre></div></div>

<p>两种方法计算的结果相当接近，从下面的图示可以看出，收敛速度还挺快，10次迭代后的误差为2.7416374433878263e-11，已经很小了。</p>

<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q2/cg_error.png" alt="img" align="center" class="center_img" />
</figure>

<p>通过上面的一个简单实验，说明该方法精度和收敛速度均不错。</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="math" /><summary type="html"><![CDATA[AI Chat Series]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">SO(3) Orthogonalization</title><link href="https://sunbingfeng.github.io/blog/R_orthogonalize/" rel="alternate" type="text/html" title="SO(3) Orthogonalization" /><published>2025-03-05T00:00:00+00:00</published><updated>2025-03-05T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/R_orthogonalize</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/R_orthogonalize/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第3篇，主要介绍实现SO(3)的正交化运算。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>之前让AI帮助实现了一个简易的SO(3)类，其中有一段SO(3)的正交化操作的代码，如下所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SO3</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ... existing code ...</span>

    <span class="c1">// Orthogonalize the rotation matrix</span>
    <span class="kt">void</span> <span class="n">orthogonalize</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">R_</span><span class="p">;</span>
        
        <span class="c1">// First column remains unchanged</span>
        <span class="c1">// Normalize first column</span>
        <span class="kt">double</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">;</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">;</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">;</span>

        <span class="c1">// Second column - remove projection onto first column and normalize</span>
        <span class="kt">double</span> <span class="n">dot</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dot</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dot</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dot</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">;</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">;</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">;</span>

        <span class="c1">// Third column - cross product of first two columns</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>

        <span class="n">R_</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>其就是基于Gram-Schmidt正交化方法实现的，只能保证R的列向量是正交的，不能保证是R_的最优逼近。因此，再跟AI聊一下，让他帮改进一下。</p>

<h2 id="ask-the-ai">Ask the AI</h2>
<blockquote>
  <p>Me: This orthogonalization method only ensure that the axises are orthogonal, but can not guarantee the R is close to R_. In theory, we should use the equation \(R = (R*R^T)^{-1/2}*R\) instead. So what’s your opinion?</p>

  <p>AI: You’re absolutely right! The current Gram-Schmidt orthogonalization method doesn’t minimize the distance to the original matrix R. The formula you suggested R = (RR^T)^(-1/2)R is known as the Polar Decomposition method, which finds the closest orthogonal matrix to R in Frobenius norm.</p>
</blockquote>

<p>Here’s an improved implementation:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">orthogonalize</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. Compute S = R*R^T</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">S</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">R_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">R_</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 2. Compute eigenvalues and eigenvectors of S</span>
    <span class="c1">// Since S is symmetric positive definite, we can use simpler methods</span>
    <span class="c1">// Here using Newton iteration for inverse square root</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Sinv_sqrt</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    
    <span class="c1">// Newton iteration for inverse square root</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Usually converges in 2-3 iterations</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">Sinv_sqrt</span><span class="p">;</span>
        
        <span class="c1">// Sinv_sqrt = (3I - Sinv_sqrt*S*Sinv_sqrt)*Sinv_sqrt/2</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">prod</span><span class="p">;</span>
        <span class="c1">// Compute Sinv_sqrt*S</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// Compute (Sinv_sqrt*S)*Sinv_sqrt</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Sinv_sqrt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">Sinv_sqrt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 3I - Sinv_sqrt</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Sinv_sqrt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">?</span> <span class="mf">3.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">Sinv_sqrt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// Multiply by original Sinv_sqrt and scale</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">Sinv_sqrt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="n">Sinv_sqrt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 3. R = (RR^T)^(-1/2)*R</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Sinv_sqrt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">R_</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">R_</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Key advantages of this approach:</p>

<ol>
  <li>Minimizes <code class="language-plaintext highlighter-rouge">||R - R_||_F</code> while maintaining orthogonality</li>
  <li>Preserves the orientation (determinant = 1)</li>
  <li>More numerically stable than Gram-Schmidt</li>
  <li>Provides the closest orthogonal matrix in Frobenius norm</li>
</ol>

<p>The Newton iteration for computing \((RR^T)^{-1/2}\) is more efficient than explicit eigendecomposition and typically converges in 2-3 iterations for matrices close to orthogonal.</p>

<blockquote>
  <p>Me: Could you give me more mathematics details about the Newton iteration?</p>

  <p>AI: Let me explain the Newton iteration for computing \((RR^T)^{-1/2}\):</p>
</blockquote>

<p>For a symmetric positive definite matrix \(S = RR^T\), we want to find \(X = S^{-1/2}\). This means:</p>

\[\begin{align}
X^2 = S^{-1} \\
XS^{1/2} = I \\
\end{align}\]

<p>The Newton iteration for computing \(X = S^{-1/2}\) is based on the function \(f(X) = X^{-2} - S\). We want \(f(X) = 0\).</p>

<p>The iteration formula is:
\(X_{k+1} = X_k(3I - X_kSX_k)/2\)</p>

<p>Here’s why it works:</p>
<ol>
  <li>If \(X\) is close to \(S^{-1/2}\), then \(XSX ≈ I\)</li>
  <li>The error term in each iteration is cubic, meaning very fast convergence</li>
  <li>The factor 1/2 ensures stability</li>
</ol>

<p>For matrices close to orthogonal (like our rotation matrices), the iteration typically converges in 2-3 steps.</p>

<p>Here’s a more detailed implementation with comments:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">orthogonalize</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Compute S = RR^T</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">S</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">R_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">R_</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Initial guess: X₀ = S (for matrices close to orthogonal)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    
    <span class="c1">// Newton iteration: Xₖ₊₁ = Xₖ(3I - XₖSXₖ)/2</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Store current X</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">X_k</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
        
        <span class="c1">// Compute XₖS</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">XS</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">XS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">XS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">X_k</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// Compute XₖSXₖ</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">XSX</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">XSX</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">XSX</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">XS</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">X_k</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// Compute 3I - XₖSXₖ</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">XSX</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">?</span> <span class="mf">3.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">XSX</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// Compute Xₖ₊₁ = Xₖ(3I - XₖSXₖ)/2</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">X_k</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">XSX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Finally compute R = S^(-1/2)R</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">R_</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">R_</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The convergence can be monitored by checking <code class="language-plaintext highlighter-rouge">||XSX - I||</code>, but for rotation matrices that are already close to orthogonal, a fixed number of iterations (3-5) is usually sufficient.</p>

<blockquote>
  <p>Me: As the Newton method should calculate the gradient, in order to obtain the iteration formula, so is this iteration formula obtained through this way?</p>
</blockquote>

<blockquote>
  <p>AI: Yes, this Newton iteration formula for computing \(S^{-1/2}\) is derived from the Newton-Raphson method, but in a matrix form. Let me explain the derivation:</p>
</blockquote>

<ol>
  <li>
    <p>We want to find X such that \(X^2 = S^{-1}\)
This can be rewritten as: \(f(X) = X^{-2} - S = 0\)</p>
  </li>
  <li>
    <p>The Newton iteration formula in general is:
\(X_{k+1} = X_k - [f'(X_k)]^{-1}f(X_k)\)</p>
  </li>
  <li>
    <p>For our matrix function \(f(X) = X^{-2} - S\), the derivative (Fréchet derivative) is: \(f'(X)H = -2X^{-3}H\), where H is the direction of derivative</p>
  </li>
  <li>
    <p>Substituting into Newton’s formula:</p>
  </li>
</ol>

\[\\
\begin{align*}
X_{k+1} &amp;= X_k + \frac{1}{2}X_k^3(X_k^{-2} - S) \\
    &amp;= X_k(I + \frac{1}{2}(I - X_kSX_k)) \\
    &amp;= X_k(\frac{3}{2}I - \frac{1}{2}X_kSX_k) \\
    &amp;= X_k(3I - X_kSX_k)/2 \\
\end{align*}
\\\]

<p>This is how we arrive at the iteration formula. The cubic convergence rate comes from the fact that if X is close to S^(-1/2), then the error in the next iteration is cubed.</p>

<blockquote>
  <p>Me: You substitue the \(X_k^2*S\) with \(X_k * S * X_k\), so why these two equal?</p>
</blockquote>

<blockquote>
  <p>AI:For general matrices, \(X_k^2*S ≠ X_k*S*X_k\). However, in our case, we’re working with symmetric matrices where:</p>
</blockquote>

<ol>
  <li>\(S = RR^T\) is symmetric</li>
  <li>\(X_k\) converges to \(S^{-1/2}\), which is also symmetric</li>
  <li>For symmetric matrices, matrix multiplication is associative and the order doesn’t matter when multiplying with their own powers</li>
</ol>

<p>Therefore, in this specific context:</p>
<ul>
  <li>When \(X_k\) is symmetric (which it is in each iteration)</li>
  <li>And \(S\) is symmetric (which it is by construction as \(RR^T\))</li>
  <li>Then \(X_k^2*S = X_k*S*X_k\)</li>
</ul>

<p>This property is crucial for the Newton iteration to work correctly. The symmetry of all matrices involved allows us to write the iteration in either form without changing the result.</p>

<p>If we were working with non-symmetric matrices, we would need to be much more careful about the order of matrix multiplication.</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="math" /><summary type="html"><![CDATA[AI Chat Series]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">SO(3) Logarithm</title><link href="https://sunbingfeng.github.io/blog/SO(3)_Log/" rel="alternate" type="text/html" title="SO(3) Logarithm" /><published>2025-03-01T00:00:00+00:00</published><updated>2025-03-01T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/SO(3)_Log</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/SO(3)_Log/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第2篇，主要介绍实现SO(3)的对数运算。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>有一段SO(3)的对数操作的代码，如下所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Logrithm of a Rotation Matrix */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Log</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="n">trace</span><span class="p">();</span>
    <span class="n">T</span> <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr</span> <span class="o">&gt;</span> <span class="mf">3.0</span> <span class="o">-</span> <span class="mf">1e-6</span> <span class="o">||</span> <span class="n">tr</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">tr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">K</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>我想让AI帮我检查一下，是否有潜在的Issues</p>

<h2 id="ask-the-ai">Ask the AI</h2>

<blockquote>
  <p>Me: this function is used to calculate the tangent of the Rotation manifold, so please check its validity</p>
</blockquote>

<blockquote>
  <p>AI: This function calculates the logarithm map of a rotation matrix (SO(3) -&gt; so(3)), converting a rotation matrix to its corresponding rotation vector (axis-angle representation). Let me analyze its validity:</p>
</blockquote>

<ol>
  <li>Mathematical Background:
    <ul>
      <li>For a rotation matrix R ∈ SO(3), its logarithm gives a skew-symmetric matrix in so(3)</li>
      <li>The formula used is based on Rodrigues’ formula in reverse</li>
      <li>The result is a 3×1 vector ω where [ω]ₓ is the skew-symmetric matrix</li>
    </ul>
  </li>
  <li>Code Analysis:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Trace is used to find rotation angle</span>
 <span class="k">const</span> <span class="n">T</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="n">trace</span><span class="p">();</span>
 <span class="c1">// Calculate rotation angle theta</span>
 <span class="n">T</span> <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr</span> <span class="o">&gt;</span> <span class="mf">3.0</span> <span class="o">-</span> <span class="mf">1e-6</span> <span class="o">||</span> <span class="n">tr</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">tr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

 <span class="c1">// Extract the skew-symmetric part</span>
 <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">K</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="c1">// [R - R^T]_23</span>
                     <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>    <span class="c1">// [R - R^T]_31</span>
                     <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>   <span class="c1">// [R - R^T]_12</span>

 <span class="c1">// Scale based on angle</span>
 <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>Validity Check:
    <ul>
      <li>✅ Trace formula is correct: tr(R) = 1 + 2cos(θ)</li>
      <li>✅ Special case handling when θ ≈ 0 (identity rotation)</li>
      <li>✅ Extraction of skew-symmetric part is correct</li>
      <li>✅ Scaling factor θ/(2sin(θ)) is correct for non-zero angles</li>
    </ul>
  </li>
  <li>Potential Issues:
    <ul>
      <li>⚠️ The threshold 1e-6 for trace comparison might be too tight for some applications</li>
      <li>⚠️ No handling for the case when θ = π (180° rotation)</li>
      <li>⚠️ Could have numerical stability issues near θ = π</li>
    </ul>
  </li>
</ol>

<p>Here’s an improved version:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Log</span><span class="p">(</span><span class="k">const</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="n">trace</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">cos_theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
    
    <span class="c1">// Clamp cos_theta to [-1,1] to handle numerical errors</span>
    <span class="n">T</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">cos_theta</span><span class="p">)));</span>
    
    <span class="c1">// Extract skew-symmetric part</span>
    <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">K</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                          <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                          <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Near identity rotation</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">M_PI</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 180-degree rotation case</span>
        <span class="c1">// Need to extract rotation axis from R+I</span>
        <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">axis</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">max_diag</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">max_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_diag</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">max_diag</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">max_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">max_idx</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">max_idx</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">max_idx</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
        <span class="n">axis</span> <span class="o">+=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">Unit</span><span class="p">(</span><span class="n">max_idx</span><span class="p">);</span>
        <span class="n">axis</span><span class="p">.</span><span class="n">normalize</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">axis</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// General case</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">*</span> <span class="n">K</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The improvements include:</p>
<ol>
  <li>Better handling of numerical stability near identity</li>
  <li>Added handling for 180-degree rotations</li>
  <li>Clamping of cos_theta to prevent acos domain errors</li>
  <li>More robust threshold checks</li>
</ol>

<p>This implementation should handle all cases in SO(3) more robustly while maintaining the mathematical correctness of the logarithm map.</p>

<blockquote>
  <p>Me: please give me more details about the case when 180-degree rotation</p>
</blockquote>

<blockquote>
  <p>AI: Let me explain the 180-degree rotation case in detail:</p>
</blockquote>

<p>When θ = π (180°), we have special issues because:</p>
<ol>
  <li>sin(θ) = 0, making the formula θ/(2sin(θ)) undefined</li>
  <li>The trace = -1, making it hard to determine the rotation axis</li>
</ol>

<p>Here’s a detailed analysis:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Log</span><span class="p">(</span><span class="k">const</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="n">trace</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">cos_theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>  <span class="c1">// For 180°, cos_theta = -1</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">cos_theta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// Check if it's close to 180°</span>
        <span class="c1">// For 180° rotation:</span>
        <span class="c1">// R = I + 2[k]_x^2, where k is the rotation axis</span>
        <span class="c1">// R + I = 2kk^T</span>
        <span class="c1">// Therefore, the column with largest diagonal entry in (R + I)</span>
        <span class="c1">// gives us the rotation axis</span>
        
        <span class="n">T</span> <span class="n">max_diag</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Diagonal elements of R + I</span>
        <span class="kt">int</span> <span class="n">max_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1">// Find the largest diagonal element</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_diag</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">max_diag</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">max_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// Extract rotation axis from the corresponding column</span>
        <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">axis</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">max_idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// Return π times the rotation axis</span>
        <span class="k">return</span> <span class="n">M_PI</span> <span class="o">*</span> <span class="n">axis</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// ... rest of the code for non-180° cases ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Mathematical Background:</p>
<ol>
  <li>
    <p>For a 180° rotation around axis k (unit vector):
\(R = I + 2[k]_×^2 = I - 2(k k^T - I) = 2k k^T - I\)</p>
  </li>
  <li>
    <p>Therefore:
\(R + I = 2k k^T\)</p>
  </li>
  <li>
    <p>Properties of this case:</p>
    <ul>
      <li>Trace(R) = -1</li>
      <li>R is symmetric</li>
      <li>Eigenvalues are {-1, -1, 1}</li>
      <li>Eigenvector with eigenvalue 1 is the rotation axis</li>
    </ul>
  </li>
</ol>

<p>Example:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Test case for 180° rotation around x-axis</span>
<span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">R_180_x</span><span class="p">;</span>
<span class="n">R_180_x</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>
           <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
           <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">log_R</span> <span class="o">=</span> <span class="n">Log</span><span class="p">(</span><span class="n">R_180_x</span><span class="p">);</span>
<span class="c1">// Expected result: [π, 0, 0]^T</span>
</code></pre></div></div>

<p>Key Points:</p>
<ol>
  <li>We can’t use the standard formula θ/(2sin(θ)) * K because sin(π) = 0</li>
  <li>The rotation axis is the eigenvector corresponding to eigenvalue 1</li>
  <li>We can find this axis by looking at R + I</li>
  <li>The column of R + I with the largest diagonal entry gives us the most numerically stable way to compute the axis</li>
</ol>

<p>This improved handling of 180° rotations makes the logarithm map complete and numerically stable for all rotation matrices in SO(3).</p>

<blockquote>
  <p>Me: 这里补充一下，180°旋转的时候，通过上面的方法，\(R-R^T\)，是没法恢复出k的，因为\(R-R^T\)是0矩阵，所以需要通过\(R+I\)来恢复出k</p>
</blockquote>

<p>下面继续…</p>

<blockquote>
  <p>Me: I’m confused with the switch case, it’s a bit different with the above logic “axis += wlt::Matrix&lt;T, 3, 1&gt;::Unit(max_idx);”</p>
</blockquote>

<p>Let me explain the difference between these two approaches for finding the rotation axis in a 180° rotation:</p>

<ol>
  <li>The simpler approach you mentioned:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">axis</span> <span class="o">=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">max_idx</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">max_idx</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="n">max_idx</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">axis</span> <span class="o">+=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">Unit</span><span class="p">(</span><span class="n">max_idx</span><span class="p">);</span>
<span class="n">axis</span><span class="p">.</span><span class="n">normalize</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>The switch case approach in the code:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">// When x-axis has largest diagonal</span>
 <span class="n">axis</span> <span class="o">=</span> <span class="n">wlt</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
     <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span>           <span class="c1">// = sqrt(2k_x^2) = |k_x|</span>
     <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(...),</span>    <span class="c1">// = k_x*k_y / |k_x|</span>
     <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(...)</span>     <span class="c1">// = k_x*k_z / |k_x|</span>
 <span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>The switch case approach is mathematically more precise because:</p>
<ol>
  <li>For a 180° rotation, \(R + I = 2kk^T\) where \(k\) is the unit rotation axis</li>
  <li>The diagonal elements of \(2kk^T\) are \(2k_x^2, 2k_y^2, 2k_z^2\)</li>
  <li>The off-diagonal elements are \(2k_xk_y, 2k_xk_z, 2k_yk_z\)</li>
</ol>

<p>This gives us a way to directly compute the components of k without needing normalization.</p>

<p>However, both approaches should give the same result, with the simpler approach being more intuitive but potentially less numerically stable.</p>

<blockquote>
  <p>Me: This line <code class="language-plaintext highlighter-rouge">(R(0,1) + R(1,0)) * 0.25 / sqrt(...),    // = k_x*k_y / |k_x|</code>,
why not use the same method as obtaining the k_x to obtain the k_y</p>
</blockquote>

<blockquote>
  <p>AI: Ah, you raise a good point! Let me explain why we can’t use the same method for all components:</p>
</blockquote>

<p>For a 180° rotation around axis k = [k_x, k_y, k_z]:</p>

<ol>
  <li>When we choose the x-component (case 0), we know:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="n">k_x</span><span class="o">^</span><span class="mi">2</span>        <span class="c1">// Diagonal term</span>
<span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">k_x</span><span class="o">*</span><span class="n">k_y</span> <span class="c1">// Off-diagonal term</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>We could try to get k_y from \(R(1,1) + 1 = 2k_y^2\), but in this case (when x-component is largest), this value would be close to zero and numerically unstable.</p>
  </li>
  <li>Instead, we use:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">k_x</span> <span class="o">=</span> <span class="err">±</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">// Get magnitude from diagonal</span>
<span class="n">k_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">k_x</span><span class="p">)</span> <span class="c1">// Use off-diagonal for sign and magnitude</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>You’re right that theoretically we could use sqrt((R(1,1) + 1)/2) to get k_y directly, but numerically it’s more stable to use the off-diagonal elements when we’re working with the non-dominant components.</p>

<p>This is why we use different formulas for the dominant component (using sqrt) versus the other components (using ratios).</p>]]></content><author><name></name></author><category term="Y-2025" /><category term="math" /><summary type="html"><![CDATA[AI Chat Series]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Fast exp implementations</title><link href="https://sunbingfeng.github.io/blog/exp_fast_implementations/" rel="alternate" type="text/html" title="Fast exp implementations" /><published>2025-02-28T00:00:00+00:00</published><updated>2025-02-28T00:00:00+00:00</updated><id>https://sunbingfeng.github.io/blog/exp_fast_implementations</id><content type="html" xml:base="https://sunbingfeng.github.io/blog/exp_fast_implementations/"><![CDATA[<blockquote>
  <p>本文是AI Chat系列文章的第1篇，主要介绍如何快速实现一个高效的指数函数计算。</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>指数函数计算是科学计算中非常常见的一个问题，尤其是在机器学习、深度学习等领域。指数函数计算的公式如下：</p>

\[e^x = \sum_{n=0}^{\infty} \frac{x^n}{n!}\]

<h2 id="ask-the-ai">Ask the AI</h2>

<blockquote>
  <p>hello, do you know how to do iterative solver for the exp operation, to reduce computation cost?</p>
</blockquote>

<blockquote>
  <p>Yes! There are several iterative methods to approximate the exponential function. Here are two common approaches:</p>
</blockquote>

<ol>
  <li>
    <p>Taylor Series Expansion (simpler but less efficient):</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">float</span> <span class="nf">exp_taylor</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">terms</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">float</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
        
     <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">terms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">term</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">i</span><span class="p">;</span>
         <span class="n">result</span> <span class="o">+=</span> <span class="n">term</span><span class="p">;</span>
     <span class="p">}</span>
        
     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>CORDIC-like Algorithm (more efficient for embedded systems):</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Fixed-point implementation (Q16.16 format)</span>
 <span class="cp">#define FP_SHIFT 16
</span> <span class="cp">#define FP_ONE (1 &lt;&lt; FP_SHIFT)
</span> <span class="cp">#define FP_MASK ((1 &lt;&lt; FP_SHIFT) - 1)
</span>
 <span class="c1">// Pre-computed exp(2^-k) values in Q16.16</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">exp_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
     <span class="mi">178145</span><span class="p">,</span> <span class="c1">// exp(-1)</span>
     <span class="mi">133652</span><span class="p">,</span> <span class="c1">// exp(-2)</span>
     <span class="mi">115832</span><span class="p">,</span> <span class="c1">// exp(-3)</span>
     <span class="mi">107555</span><span class="p">,</span> <span class="c1">// exp(-4)</span>
     <span class="mi">103520</span><span class="p">,</span> <span class="c1">// exp(-5)</span>
     <span class="mi">101567</span><span class="p">,</span> <span class="c1">// exp(-6)</span>
     <span class="mi">100613</span><span class="p">,</span> <span class="c1">// exp(-7)</span>
     <span class="mi">100139</span>  <span class="c1">// exp(-8)</span>
 <span class="p">};</span>

 <span class="kt">int32_t</span> <span class="nf">exp_cordic</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// Handle x = 0 case</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">FP_ONE</span><span class="p">;</span>
        
     <span class="c1">// Scale input to [-1,1] range</span>
     <span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">FP_ONE</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">x</span> <span class="o">-=</span> <span class="n">FP_ONE</span><span class="p">;</span>
         <span class="n">scale</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">FP_ONE</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">x</span> <span class="o">+=</span> <span class="n">FP_ONE</span><span class="p">;</span>
         <span class="n">scale</span><span class="o">--</span><span class="p">;</span>
     <span class="p">}</span>
        
     <span class="kt">int32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">FP_ONE</span><span class="p">;</span>
     <span class="kt">int32_t</span> <span class="n">power</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        
     <span class="c1">// Iterative multiplication</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">power</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">exp_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">FP_SHIFT</span><span class="p">;</span>
         <span class="p">}</span>
         <span class="n">power</span> <span class="o">=</span> <span class="n">power</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
     <span class="p">}</span>
        
     <span class="c1">// Apply scaling</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="mi">178145</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">FP_SHIFT</span><span class="p">;</span>  <span class="c1">// multiply by e</span>
         <span class="n">scale</span><span class="o">--</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="mi">23674</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">FP_SHIFT</span><span class="p">;</span>   <span class="c1">// multiply by 1/e</span>
         <span class="n">scale</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span>
        
     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Fast Approximation (most efficient but less accurate):</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">float</span> <span class="nf">fast_exp</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Based on the identity: e^x = 2^(x/ln(2))</span>
        <span class="k">union</span> <span class="p">{</span>
            <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
            <span class="kt">int32_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
        
        <span class="k">const</span> <span class="kt">float</span> <span class="n">ln2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">6931471805599453</span><span class="n">f</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">one_over_ln2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">4426950408889634</span><span class="n">f</span><span class="p">;</span>
        
        <span class="c1">// Scale by 1/ln(2)</span>
        <span class="kt">float</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">one_over_ln2</span><span class="p">;</span>
        
        <span class="c1">// Split into integer and fractional parts</span>
        <span class="kt">int32_t</span> <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">fx</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">;</span>
        
        <span class="c1">// Approximate 2^f using a small polynomial</span>
        <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">6931471805599453</span><span class="n">f</span> <span class="o">+</span> 
                            <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">2402265069591006</span><span class="n">f</span> <span class="o">+</span> 
                            <span class="n">f</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05550410</span><span class="mi">86648216</span><span class="n">f</span><span class="p">));</span>
        
        <span class="c1">// Construct 2^ix * y</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">127</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span>
        <span class="n">u</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">ix</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="err">```</span></code></pre></figure>

<p><strong>Usage comparison:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">;</span>

<span class="c1">// Method 1: Taylor series (slower but simple)</span>
<span class="kt">float</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">exp_taylor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>  <span class="c1">// 10 terms</span>

<span class="c1">// Method 2: CORDIC-like (good for fixed-point)</span>
<span class="kt">int32_t</span> <span class="n">x_fixed</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">*</span> <span class="n">FP_ONE</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">result2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">exp_cordic</span><span class="p">(</span><span class="n">x_fixed</span><span class="p">)</span> <span class="o">/</span> <span class="n">FP_ONE</span><span class="p">;</span>

<span class="c1">// Method 3: Fast approximation (fastest)</span>
<span class="kt">float</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">fast_exp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>Key points:</strong></p>

<ol>
  <li>Taylor series:
    <ul>
      <li>Simple to understand</li>
      <li>Needs more terms for accuracy</li>
      <li>Good for small x values</li>
    </ul>
  </li>
  <li>CORDIC-like:
    <ul>
      <li>Good for fixed-point arithmetic</li>
      <li>Consistent precision</li>
      <li>Table-based approach saves computation</li>
    </ul>
  </li>
  <li>Fast approximation:
    <ul>
      <li>Fastest method</li>
      <li>Uses floating-point tricks</li>
      <li>Less accurate but often sufficient</li>
    </ul>
  </li>
</ol>

<p><strong>Choose based on your needs:</strong></p>
<ul>
  <li>Need high accuracy? Use Taylor series</li>
  <li>Using fixed-point? Use CORDIC-like</li>
  <li>Need speed over accuracy? Use fast approximation</li>
</ul>

<p>The fast approximation method is often good enough for most applications while being much faster than standard library exp().</p>

<h2 id="experiment">Experiment</h2>
<p>下面来测试下Fast approximation方法的性能。我让AI给我写了一个简易的测试benchmark：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">TicToc</span> <span class="n">timer</span><span class="p">;</span>
    <span class="n">timer</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mo">01</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"x = %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"one exp time = %fms</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">timer</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="o">/</span> <span class="n">N</span><span class="p">);</span>
</code></pre></div></div>
<p>在一款Cortex-M4核（96MHz）的嵌入式核心上评估，结果如下所示：</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>单次exp耗时</th>
      <th>x</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>标准库</td>
      <td>0.043ms</td>
      <td>100.5005</td>
    </tr>
    <tr>
      <td>快速近似</td>
      <td>0.0032ms</td>
      <td>#.#</td>
    </tr>
  </tbody>
</table>

<p>可以发现fast approximation方法的单次exp耗时只有标准库的1/13，提升效果还是明显的，但是最终结果出现表征错误。那是为什么呢？下面进一步分析。</p>

<p>仔细分析，就会发现，由于float精度的限制，不考虑符号，其只能表征约\(2^{-126}\)到 \(2^{127}\)。因此，其幂指数超过127时，就会出现溢出，从而导致结果错误。当N设置为1000时，再次评估，就可以得到正确的结果了。</p>

<p>下面评估下fast approximation方法的精度</p>

<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q1/fast_exp.png" alt="img" align="center" class="center_img" />
</figure>

<p>可以发现，当x=100时，fast approximation方法的精度已经非常差了。如果x值不大，精度还是可以接受的。</p>
<figure>
<img src="https://sunbingfeng.github.io/images/2025-Q1/fast_exp_2.png" alt="img" align="center" class="center_img" />
</figure>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>在嵌入式平台上，如果对精度要求不高，fast approximation方法是一个不错的选择，可以显著提升计算效率。</li>
</ul>]]></content><author><name></name></author><category term="Y-2025" /><category term="algorithm" /><summary type="html"><![CDATA[AI Chat Series]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://sunbingfeng.github.io/" /><media:content medium="image" url="https://sunbingfeng.github.io/" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>